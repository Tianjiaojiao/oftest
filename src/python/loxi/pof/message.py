# Copyright (c) 2008 The Board of Trustees of The Leland Stanford Junior University
# Copyright (c) 2011, 2012 Open Networking Foundation
# Copyright (c) 2012, 2013 Big Switch Networks, Inc.
# See the file LICENSE.pyloxi which should have been included in the source distribution

# Automatically generated by LOXI from template module.py
# Do not modify

import struct
import loxi
import util
import loxi.generic_util

import sys
ofp = sys.modules['loxi.pof']

MULTIPLE_SLOTS = False

#------POF message heade----------------------------------------------------------

class message(loxi.OFObject): #pof_header
    subtypes = {}

    version = 4 #pof

    def __init__(self, type=None, xid=None):
        if type != None:
            self.type = type
        else:
            self.type = 0
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)  #length
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        subtype, = reader.peek('B', 1) #peek is seen at generic_util.py
        subclass = message.subtypes.get(subtype)
        if subclass:
            return subclass.unpack(reader)

        obj = message()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        obj.type = reader.read("!B")[0]
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.type != other.type: return False
        if self.xid != other.xid: return False
        return True

    def pretty_print(self, q):
        q.text("message {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
            q.breakable()
        q.text('}')

#-----hello message, with no body--------------------------------------------------

class hello(message):
    version = 4
    type = 0

    def __init__(self, xid=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = hello()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 0)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        return True

    def pretty_print(self, q):
        q.text("hello {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
            q.breakable()
        q.text('}')

message.subtypes[0] = hello

#-----error message---------------------------------------------------------------

class error_msg(message): #pof_error
    subtypes = {}   

    version = 4
    type = 1

    def __init__(self, xid=None, err_type=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if err_type != None:
            self.err_type = err_type
        else:
            self.err_type = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0))# placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!H", self.err_type))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        subtype, = reader.peek('!H', 8)
        subclass = error_msg.subtypes.get(subtype)
        if subclass:
            return subclass.unpack(reader)

        obj = error_msg()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 1)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        obj.err_type = reader.read("!H")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.err_type != other.err_type: return False
        return True

    def pretty_print(self, q):
        q.text("error_msg {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
            q.breakable()
        q.text('}')

message.subtypes[1] = error_msg

class hello_failed_error_msg(error_msg):
    version = 4
    type = 1
    err_type = 0

    def __init__(self, xid=None, code=None, device_id=None, slotId=None,  err_str=None):
        if xid != None:
             self.xid = xid
        else:
            self.xid = None
        if code != None:
            self.code = code
        else:
            self.code = 0
        if device_id != None:
            self.device_id = device_id
        else:
            self.device_id = 0
        if slotID != None:
            self.slotID = slotID
        else:
            self.slotID = 0
        if err_str != None:
            self.err_str = err_str
        else:
            self.err_str = ""
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!H", self.err_type))
        packed.append(struct.pack("!H", self.code))
        packed.append(struct.pack("!L", self.device_id))
        packed.append(struct.pack("!H", self.slotID))
        packed.append('\x00' * 6)
        packed.append(struct.pack("!256s", self.err_str))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = hello_failed_error_msg()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 1)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        _err_type = reader.read("!H")[0]
        assert(_err_type == 0)
        obj.code = reader.read("!H")[0]
        obj.device_id = reader.read("!L")[0]
        obj.slotID = reader.read("!H")[0]
        reader.skip(6)
        obj.err_str = reader.read("!256s")[0].rstrip("\x00")
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.code != other.code: return False
        if self.device_id != other.device_id: return False
        if self.slotID != other.slotID: return False
        if self.err_str != other.err_str: return False
        return True

    def pretty_print(self, q):
        q.text("hello_failed_error_msg {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("code = ");
                q.text("%#x" % self.code)
                q.text(","); q.breakable()
                q.text("device_id = ");
                q.text("%#x" % self.device_id)
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(","); q.breakable()
                q.text("err_str = ");
                q.pp(self.err_str)
            q.breakable()
        q.text('}')

error_msg.subtypes[0] = hello_failed_error_msg

class bad_request_error_msg(error_msg):
    version = 4
    type = 1
    err_type = 1

    def __init__(self, xid=None, code=None, device_id=None, slotID=None, err_str=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if code != None:
            self.code = code
        else:
            self.code = 0
        if device_id != None:
            self.device_id = device_id
        else:
            self.device_id = 0
        if slotID != None:
            self.slotID = slotID
        else:
            self.slotID = 0
        if err_str != None:
            self.err_str = err_str
        else:
            self.err_str = ""
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!H", self.err_type))
        packed.append(struct.pack("!H", self.code))
        packed.append(struct.pack("!L", self.device_id))
        packed.append(struct.pack("!H", self.slotID))
        packed.append('\x00' * 6)
        packed.append(struct.pack("!256s", self.err_str))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bad_request_error_msg()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 1)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        _err_type = reader.read("!H")[0]
        assert(_err_type == 1)
        obj.code = reader.read("!H")[0]
        obj.device_id = reader.read("!L")[0]
        obj.slotID = reader.read("!H")[0]
        reader.skip(6)
        obj.err_str = reader.read("!256s")[0].rstrip("\x00")
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.code != other.code: return False
        if self.device_id != other.device_id: return False
        if self.slotID != other.slotID: return False
        if self.err_str != other.err_str: return False
        return True

    def pretty_print(self, q):
        q.text("bad_request_error_msg {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("code = ");
                q.text("%#x" % self.code)
                q.text(","); q.breakable()
                q.text("device_id = ");
                q.text("%#x" % self.device_id)
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(","); q.breakable()
                q.text("err_str = ");
                q.pp(self.err_str)
            q.breakable()
        q.text('}')

error_msg.subtypes[1] = bad_request_error_msg

class bad_action_error_msg(error_msg):
    version = 4
    type = 1
    err_type = 2

    def __init__(self, xid=None, code=None, device_id=None, slotID=None, err_str=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if code != None:
            self.code = code
        else:
            self.code = 0
        if device_id != None:
            self.device_id = device_id
        else:
            self.device_id = 0
        if slotID != None:
            self.slotID = slotID
        else:
            self.slotID = 0
        if err_str != None:
            self.err_str = err_str
        else:
            self.err_str = ""
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!H", self.err_type))
        packed.append(struct.pack("!H", self.code))
        packed.append(struct.pack("!L", self.device_id))
        packed.append(struct.pack("!H", self.slotID))
        packed.append('\x00' * 6)
        packed.append(struct.pack("!256s", self.err_str))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bad_action_error_msg()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 1)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        _err_type = reader.read("!H")[0]
        assert(_err_type == 2)
        obj.code = reader.read("!H")[0]
        obj.device_id = reader.read("!L")[0]
        obj.slotID = reader.read("!H")[0]
        reader.skip(6)
        obj.err_str = reader.read("!256s")[0].rstrip("\x00")
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.code != other.code: return False
        if self.device_id != other.device_id: return False
        if self.slotID != other.slotID: return False
        if self.err_str != other.err_str: return False
        return True

    def pretty_print(self, q):
        q.text("bad_action_error_msg {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')

                q.text(","); q.breakable()
                q.text("code = ");
                q.text("%#x" % self.code)
                q.text(","); q.breakable()
                q.text("device_id = ");
                q.text("%#x" % self.device_id)
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(","); q.breakable()
                q.text("err_str = ");
                q.pp(self.err_str)
            q.breakable()
        q.text('}')

error_msg.subtypes[2] = bad_action_error_msg

class bad_instruction_error_msg(error_msg):
    version = 4
    type = 1
    err_type = 3

    def __init__(self, xid=None, code=None, device_id=None, slotID=None, err_str=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if code != None:
            self.code = code
        else:
            self.code = 0
        if device_id != None:
            self.device_id = device_id
        else:
            self.device_id = 0
        if slotID != None:
            self.slotID = slotID
        else:
            self.slotID = 0
        if err_str != None:
            self.err_str = err_str
        else:
            self.err_str = ""
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!H", self.err_type))
        packed.append(struct.pack("!H", self.code))
        packed.append(struct.pack("!L", self.device_id))
        packed.append(struct.pack("!H", self.slotID))
        packed.append('\x00' * 6)
        packed.append(struct.pack("!256s", self.err_str))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bad_instruction_error_msg()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 1)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        _err_type = reader.read("!H")[0]
        assert(_err_type == 3)
        obj.code = reader.read("!H")[0]
        obj.device_id = reader.read("!L")[0]
        obj.slotID = reader.read("!H")[0]
        reader.skip(6)
        obj.err_str = reader.read("!256s")[0].rstrip("\x00")
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.code != other.code: return False
        if self.device_id != other.device_id: return False
        if self.slotID != other.slotID: return False
        if self.err_str != other.err_str: return False
        return True

    def pretty_print(self, q):
        q.text("bad_instruction_error_msg {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("code = ");
                q.text("%#x" % self.code)
                q.text(","); q.breakable()
                q.text("device_id = ");
                q.text("%#x" % self.device_id)
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(","); q.breakable()
                q.text("err_str = ");
                q.pp(self.err_str)
            q.breakable()
        q.text('}')

error_msg.subtypes[3] = bad_instruction_error_msg

class bad_match_error_msg(error_msg):
    version = 4
    type = 1
    err_type = 4

    def __init__(self, xid=None, code=None, device_id=None, slotID=None, err_str=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if code != None:
            self.code = code
        else:
            self.code = 0
        if device_id != None:
            self.device_id = device_id
        else:
            self.device_id = 0
        if slotID != None:
            self.slotID = slotID
        else:
            self.slotID = 0
        if err_str != None:
            self.err_str = err_str
        else:
            self.err_str = ""
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!H", self.err_type))
        packed.append(struct.pack("!H", self.code))
        packed.append(struct.pack("!L", self.device_id))
        packed.append(struct.pack("!H", self.slotID))
        packed.append('\x00' * 6)
        packed.append(struct.pack("!256s", self.err_str))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = bad_match_error_msg()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 1)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        _err_type = reader.read("!H")[0]
        assert(_err_type == 4)
        obj.code = reader.read("!H")[0]
        obj.device_id = reader.read("!L")[0]
        obj.slotID = reader.read("!H")[0]
        reader.skip(6)
        obj.err_str = reader.read("!256s")[0].rstrip("\x00")
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.code != other.code: return False
        if self.device_id != other.device_id: return False
        if self.slotID != other.slotID: return False
        if self.err_str != other.err_str: return False
        return True

    def pretty_print(self, q):
        q.text("bad_match_error_msg {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("code = ");
                q.text("%#x" % self.code)
                q.text(","); q.breakable()
                q.text("device_id = ");
                q.text("%#x" % self.device_id)
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(","); q.breakable()
                q.text("err_str = ");
                q.pp(self.err_str)
            q.breakable()
        q.text('}')

error_msg.subtypes[4] = bad_match_error_msg

class flow_mod_failed_error_msg(error_msg):
    version = 4
    type = 1
    err_type = 5

    def __init__(self, xid=None, code=None, device_id=None, slotID=None, err_str=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if code != None:
            self.code = code
        else:
            self.code = 0
        if device_id != None:
            self.device_id = device_id
        else:
            self.device_id = 0
        if slotID != None:
            self.slotID = slotID
        else:
            self.slotID = 0
        if err_str != None:
            self.err_str = err_str
        else:
            self.err_str = ""
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!H", self.err_type))
        packed.append(struct.pack("!H", self.code))
        packed.append(struct.pack("!L", self.device_id))
        packed.append(struct.pack("!H", self.slotID))
        packed.append('\x00' * 6)
        packed.append(struct.pack("!256s", self.err_str))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = flow_mod_failed_error_msg()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 1)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        _err_type = reader.read("!H")[0]
        assert(_err_type == 5)
        obj.code = reader.read("!H")[0]
        obj.device_id = reader.read("!L")[0]
        obj.slotID = reader.read("!H")[0]
        reader.skip(6)
        obj.err_str = reader.read("!256s")[0].rstrip("\x00")
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.code != other.code: return False
        if self.device_id != other.device_id: return False
        if self.slotID != other.slotID: return False
        if self.err_str != other.err_str: return False
        return True

    def pretty_print(self, q):
        q.text("flow_mod_failed_error_msg {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("code = ");
                q.text("%#x" % self.code)
                q.text(","); q.breakable()
                q.text("device_id = ");
                q.text("%#x" % self.device_id)
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(","); q.breakable()
                q.text("err_str = ");
                q.pp(self.err_str)
            q.breakable()
        q.text('}')

error_msg.subtypes[5] = flow_mod_failed_error_msg

class group_mod_failed_error_msg(error_msg):
    version = 4
    type = 1
    err_type = 6

    def __init__(self, xid=None, code=None, device_id=None, slotID=None, err_str=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if code != None:
            self.code = code
        else:
            self.code = 0
        if device_id != None:
            self.device_id = device_id
        else:
            self.device_id = 0
        if slotID != None:
            self.slotID = slotID
        else:
            self.slotID = 0
        if err_str != None:
            self.err_str = err_str
        else:
            self.err_str = ""
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!H", self.err_type))
        packed.append(struct.pack("!H", self.code))
        packed.append(struct.pack("!L", self.device_id))
        packed.append(struct.pack("!H", self.slotID))
        packed.append('\x00' * 6)
        packed.append(struct.pack("!256s", self.err_str))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = group_mod_failed_error_msg()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 1)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        _err_type = reader.read("!H")[0]
        assert(_err_type == 6)
        obj.code = reader.read("!H")[0]
        obj.device_id = reader.read("!L")[0]
        obj.slotID = reader.read("!H")[0]
        reader.skip(6)
        obj.err_str = reader.read("!256s")[0].rstrip("\x00")
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.code != other.code: return False
        if self.device_id != other.device_id: return False
        if self.slotID != other.slotID: return False
        if self.err_str != other.err_str: return False
        return True

    def pretty_print(self, q):
        q.text("group_mod_failed_error_msg {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("code = ");
                q.text("%#x" % self.code)
                q.text(","); q.breakable()
                q.text("device_id = ");
                q.text("%#x" % self.device_id)
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(","); q.breakable()
                q.text("err_str = ");
                q.pp(self.err_str)
            q.breakable()
        q.text('}')

error_msg.subtypes[6] = group_mod_failed_error_msg

class port_mod_failed_error_msg(error_msg):
    version = 4
    type = 1
    err_type = 7

    def __init__(self, xid=None, code=None, device_id=None, slotID=None, err_str=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if code != None:
            self.code = code
        else:
            self.code = 0
        if device_id != None:
            self.device_id = device_id
        else:
            self.device_id = 0
        if slotID != None:
            self.slotID = slotID
        else:
            self.slotID = 0
        if err_str != None:
            self.err_str = err_str
        else:
            self.err_str = ""
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!H", self.err_type))
        packed.append(struct.pack("!H", self.code))
        packed.append(struct.pack("!L", self.device_id))
        packed.append(struct.pack("!H", self.slotID))
        packed.append('\x00' * 6)
        packed.append(struct.pack("!256s", self.err_str))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = port_mod_failed_error_msg()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 1)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        _err_type = reader.read("!H")[0]
        assert(_err_type == 7)
        obj.code = reader.read("!H")[0]
        obj.device_id = reader.read("!L")[0]
        obj.slotID = reader.read("!H")[0]
        reader.skip(6)
        obj.err_str = reader.read("!256s")[0].rstrip("\x00")
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.code != other.code: return False
        if self.device_id != other.device_id: return False
        if self.slotID != other.slotID: return False
        if self.err_str != other.err_str: return False
        return True

    def pretty_print(self, q):
        q.text("port_mod_failed_error_msg {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("code = ");
                q.text("%#x" % self.code)
                q.text(","); q.breakable()
                q.text("device_id = ");
                q.text("%#x" % self.device_id)
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(","); q.breakable()
                q.text("err_str = ");
                q.pp(self.err_str)
            q.breakable()
        q.text('}')

error_msg.subtypes[7] = port_mod_failed_error_msg

class table_mod_failed_error_msg(error_msg):
    version = 4
    type = 1
    err_type = 8

    def __init__(self, xid=None, code=None, device_id=None, slotID=None, err_str=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if code != None:
            self.code = code
        else:
            self.code = 0
        if device_id != None:
            self.device_id = device_id
        else:
            self.device_id = 0
        if slotID != None:
            self.slotID = slotID
        else:
            self.slotID = 0
        if err_str != None:
            self.err_str = err_str
        else:
            self.err_str = ""
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!H", self.err_type))
        packed.append(struct.pack("!H", self.code))
        packed.append(struct.pack("!L", self.device_id))
        packed.append(struct.pack("!H", self.slotID))
        packed.append('\x00' * 6)
        packed.append(struct.pack("!256s", self.err_str))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = table_mod_failed_error_msg()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 1)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        _err_type = reader.read("!H")[0]
        assert(_err_type == 8)
        obj.code = reader.read("!H")[0]
        obj.device_id = reader.read("!L")[0]
        obj.slotID = reader.read("!H")[0]
        reader.skip(6)
        obj.err_str = reader.read("!256s")[0].rstrip("\x00")
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.code != other.code: return False
        if self.device_id != other.device_id: return False
        if self.slotID != other.slotID: return False
        if self.err_str != other.err_str: return False
        return True

    def pretty_print(self, q):
        q.text("table_mod_failed_error_msg {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("code = ");
                q.text("%#x" % self.code)
                q.text(","); q.breakable()
                q.text("device_id = ");
                q.text("%#x" % self.device_id)
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(","); q.breakable()
                q.text("err_str = ");
                q.pp(self.err_str)

            q.breakable()
        q.text('}')

error_msg.subtypes[8] = table_mod_failed_error_msg

class queue_op_failed_error_msg(error_msg):
    version = 4
    type = 1
    err_type = 9

    def __init__(self, xid=None, code=None, device_id=None, slotID=None, err_str=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if code != None:
            self.code = code
        else:
            self.code = 0
        if device_id != None:
            self.device_id = device_id
        else:
            self.device_id = 0
        if slotID != None:
            self.slotID = slotID
        else:
            self.slotID = 0
        if err_str != None:
            self.err_str = err_str
        else:
            self.err_str = ""
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!H", self.err_type))
        packed.append(struct.pack("!H", self.code))
        packed.append(struct.pack("!L", self.device_id))
        packed.append(struct.pack("!H", self.slotID))
        packed.append('\x00' * 6)
        packed.append(struct.pack("!256s", self.err_str))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = queue_op_failed_error_msg()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 1)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        _err_type = reader.read("!H")[0]
        assert(_err_type == 9)
        obj.code = reader.read("!H")[0]
        obj.device_id = reader.read("!L")[0]
        obj.slotID = reader.read("!H")[0]
        reader.skip(6)
        obj.err_str = reader.read("!256s")[0].rstrip("\x00")
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.code != other.code: return False
        if self.device_id != other.device_id: return False
        if self.slotID != other.slotID: return False
        if self.err_str != other.err_str: return False
        return True

    def pretty_print(self, q):
        q.text("queue_op_failed_error_msg {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("code = ");
                q.text("%#x" % self.code)
                q.text(","); q.breakable()
                q.text("device_id = ");
                q.text("%#x" % self.device_id)
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(","); q.breakable()
                q.text("err_str = ");
                q.pp(self.err_str)
            q.breakable()
        q.text('}')

error_msg.subtypes[9] = queue_op_failed_error_msg

class switch_config_failed_error_msg(error_msg):
    version = 4
    type = 1
    err_type = 10

    def __init__(self, xid=None, code=None, device_id=None, slotID=None, err_str=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if code != None:
            self.code = code
        else:
            self.code = 0
        if device_id != None:
            self.device_id = device_id
        else:
            self.device_id = 0
        if slotID != None:
            self.slotID = slotID
        else:
            self.slotID = 0
        if err_str != None:
            self.err_str = err_str
        else:
            self.err_str = ""
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!H", self.err_type))
        packed.append(struct.pack("!H", self.code))
        packed.append(struct.pack("!L", self.device_id))
        packed.append(struct.pack("!H", self.slotID))
        packed.append('\x00' * 6)
        packed.append(struct.pack("!256s", self.err_str))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = switch_config_failed_error_msg()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 1)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        _err_type = reader.read("!H")[0]
        assert(_err_type == 10)
        obj.code = reader.read("!H")[0]
        obj.device_id = reader.read("!L")[0]
        obj.slotID = reader.read("!H")[0]
        reader.skip(6)
        obj.err_str = reader.read("!256s")[0].rstrip("\x00")
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.code != other.code: return False
        if self.device_id != other.device_id: return False
        if self.slotID != other.slotID: return False
        if self.err_str != other.err_str: return False
        return True

    def pretty_print(self, q):
        q.text("switch_config_failed_error_msg {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("code = ");
                q.text("%#x" % self.code)
                q.text(","); q.breakable()
                q.text("device_id = ");
                q.text("%#x" % self.device_id)
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(","); q.breakable()
                q.text("err_str = ");
                q.pp(self.err_str)
            q.breakable()
        q.text('}')

error_msg.subtypes[10] = switch_config_failed_error_msg

class role_request_failed_error_msg(error_msg):
    version = 4
    type = 1
    err_type = 11

    def __init__(self, xid=None, code=None, device_id=None, slotID=None, err_str=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if code != None:
            self.code = code
        else:
            self.code = 0
        if device_id != None:
            self.device_id = device_id
        else:
            self.device_id = 0
        if slotID != None:
            self.slotID = slotID
        else:
            self.slotID = 0
        if err_str != None:
            self.err_str = err_str
        else:
            self.err_str = ""
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!H", self.err_type))
        packed.append(struct.pack("!H", self.code))
        packed.append(struct.pack("!L", self.device_id))
        packed.append(struct.pack("!H", self.slotID))
        packed.append('\x00' * 6)
        packed.append(struct.pack("!256s", self.err_str))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = role_request_failed_error_msg()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 1)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        _err_type = reader.read("!H")[0]
        assert(_err_type == 11)
        obj.code = reader.read("!H")[0]
        obj.device_id = reader.read("!L")[0]
        obj.slotID = reader.read("!H")[0]
        reader.skip(6)
        obj.err_str = reader.read("!256s")[0].rstrip("\x00")
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.code != other.code: return False
        if self.device_id != other.device_id: return False
        if self.slotID != other.slotID: return False
        if self.err_str != other.err_str: return False
        return True

    def pretty_print(self, q):
        q.text("role_request_failed_error_msg {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("code = ");
                q.text("%#x" % self.code)
                q.text(","); q.breakable()
                q.text("device_id = ");
                q.text("%#x" % self.device_id)
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(","); q.breakable()
                q.text("err_str = ");
                q.pp(self.err_str)
            q.breakable()
        q.text('}')

error_msg.subtypes[11] = role_request_failed_error_msg

class meter_mod_failed_error_msg(error_msg):
    version = 4
    type = 1
    err_type = 12

    def __init__(self, xid=None, code=None, device_id=None, slotID=None, err_str=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if code != None:
            self.code = code
        else:
            self.code = 0
        if device_id != None:
            self.device_id = device_id
        else:
            self.device_id = 0
        if slotID != None:
            self.slotID = slotID
        else:
            self.slotID = 0
        if err_str != None:
            self.err_str = err_str
        else:
            self.err_str = ""
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!H", self.err_type))
        packed.append(struct.pack("!H", self.code))
        packed.append(struct.pack("!L", self.device_id))
        packed.append(struct.pack("!H", self.slotID))
        packed.append('\x00' * 6)
        packed.append(struct.pack("!256s", self.err_str))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = meter_mod_failed_error_msg()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 1)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        _err_type = reader.read("!H")[0]
        assert(_err_type == 12)
        obj.code = reader.read("!H")[0]
        obj.device_id = reader.read("!L")[0]
        obj.slotID = reader.read("!H")[0]
        reader.skip(6)
        obj.err_str = reader.read("!256s")[0].rstrip("\x00")
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.code != other.code: return False
        if self.device_id != other.device_id: return False
        if self.slotID != other.slotID: return False
        if self.err_str != other.err_str: return False
        return True

    def pretty_print(self, q):
        q.text("meter_mod_failed_error_msg {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("code = ");
                q.text("%#x" % self.code)
                q.text(","); q.breakable()
                q.text("device_id = ");
                q.text("%#x" % self.device_id)
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(","); q.breakable()
                q.text("err_str = ");
                q.pp(self.err_str)
            q.breakable()
        q.text('}')

error_msg.subtypes[12] = meter_mod_failed_error_msg

class table_features_failed_error_msg(error_msg):
    version = 4
    type = 1
    err_type = 13

    def __init__(self, xid=None, code=None, device_id=None, slotID=None, err_str=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if code != None:
            self.code = code
        else:
            self.code = 0
        if device_id != None:
            self.device_id = device_id
        else:
            self.device_id = 0
        if slotID != None:
            self.slotID = slotID
        else:
            self.slotID = 0
        if err_str != None:
            self.err_str = err_str
        else:
            self.err_str = ""
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!H", self.err_type))
        packed.append(struct.pack("!H", self.code))
        packed.append(struct.pack("!L", self.device_id))
        packed.append(struct.pack("!H", self.slotID))
        packed.append('\x00' * 6)
        packed.append(struct.pack("!256s", self.err_str))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = table_features_failed_error_msg()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 1)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        _err_type = reader.read("!H")[0]
        assert(_err_type == 13)
        obj.code = reader.read("!H")[0]
        obj.device_id = reader.read("!L")[0]
        obj.slotID = reader.read("!H")[0]
        reader.skip(6)
        obj.err_str = reader.read("!256s")[0].rstrip("\x00")
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.code != other.code: return False
        if self.device_id != other.device_id: return False
        if self.slotID != other.slotID: return False
        if self.err_str != other.err_str: return False
        return True

    def pretty_print(self, q):
        q.text("table_features_failed_error_msg {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("code = ");
                q.text("%#x" % self.code)
                q.text(","); q.breakable()
                q.text("device_id = ");
                q.text("%#x" % self.device_id)
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(","); q.breakable()
                q.text("err_str = ");
                q.pp(self.err_str)
            q.breakable()
        q.text('}')

error_msg.subtypes[13] = table_features_failed_error_msg

class software_failed_error_msg(error_msg):
    version = 4
    type = 1
    err_type = 14

    def __init__(self, xid=None, code=None, device_id=None, slotID=None, err_str=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if code != None:
            self.code = code
        else:
            self.code = 0
        if device_id != None:
            self.device_id = device_id
        else:
            self.device_id = 0
        if slotID != None:
            self.slotID = slotID
        else:
            self.slotID = 0
        if err_str != None:
            self.err_str = err_str
        else:
            self.err_str = ""
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!H", self.err_type))
        packed.append(struct.pack("!H", self.code))
        packed.append(struct.pack("!L", self.device_id))
        packed.append(struct.pack("!H", self.slotID))
        packed.append('\x00' * 6)
        packed.append(struct.pack("!256s", self.err_str))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = software_failed_error_msg()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 1)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        _err_type = reader.read("!H")[0]
        assert(_err_type == 14)
        obj.code = reader.read("!H")[0]
        obj.device_id = reader.read("!L")[0]
        obj.slotID = reader.read("!H")[0]
        reader.skip(6)
        obj.err_str = reader.read("!256s")[0].rstrip("\x00")
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.code != other.code: return False
        if self.device_id != other.device_id: return False
        if self.slotID != other.slotID: return False
        if self.err_str != other.err_str: return False
        return True

    def pretty_print(self, q):
        q.text("software_failed_error_msg {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("code = ");
                q.text("%#x" % self.code)
                q.text(","); q.breakable()
                q.text("device_id = ");
                q.text("%#x" % self.device_id)
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(","); q.breakable()
                q.text("err_str = ");
                q.pp(self.err_str)

            q.breakable()
        q.text('}')

error_msg.subtypes[14] = software_failed_error_msg

class counter_mod_failed_error_msg(error_msg):
    version = 4
    type = 1
    err_type = 15

    def __init__(self, xid=None, code=None, device_id=None, slotID=None, err_str=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if code != None:
            self.code = code
        else:
            self.code = 0
        if device_id != None:
            self.device_id = device_id
        else:
            self.device_id = 0
        if slotID != None:
            self.slotID = slotID
        else:
            self.slotID = 0
        if err_str != None:
            self.err_str = err_str
        else:
            self.err_str = ""
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!H", self.err_type))
        packed.append(struct.pack("!H", self.code))
        packed.append(struct.pack("!L", self.device_id))
        packed.append(struct.pack("!H", self.slotID))
        packed.append('\x00' * 6)
        packed.append(struct.pack("!256s", self.err_str))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = counter_mod_failed_error_msg()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 1)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        _err_type = reader.read("!H")[0]
        assert(_err_type == 15)
        obj.code = reader.read("!H")[0]
        obj.device_id = reader.read("!L")[0]
        obj.slotID = reader.read("!H")[0]
        reader.skip(6)
        obj.err_str = reader.read("!256s")[0].rstrip("\x00")  # rstrip used to remove terminator
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.code != other.code: return False
        if self.device_id != other.device_id: return False
        if self.slotID != other.slotID: return False
        if self.err_str != other.err_str: return False
        return True

    def pretty_print(self, q):
        q.text("counter_mod_failed_error_msg {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("code = ");
                q.text("%#x" % self.code)
                q.text(","); q.breakable()
                q.text("device_id = ");
                q.text("%#x" % self.device_id)
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(","); q.breakable()
                q.text("err_str = ");
                q.pp(self.err_str)
            q.breakable()
        q.text('}')

error_msg.subtypes[15] = counter_mod_failed_error_msg

class insblock_failed_error_msg(error_msg):
    version = 4
    type = 1
    err_type = 16

    def __init__(self, xid=None, code=None, device_id=None, slotID=None, err_str=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if code != None:
            self.code = code
        else:
            self.code = 0
        if device_id != None:
            self.device_id = device_id
        else:
            self.device_id = 0
        if slotID != None:
            self.slotID = slotID
        else:
            self.slotID = 0
        if err_str != None:
            self.err_str = err_str
        else:
            self.err_str = ""
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!H", self.err_type))
        packed.append(struct.pack("!H", self.code))
        packed.append(struct.pack("!L", self.device_id))
        packed.append(struct.pack("!H", self.slotID))
        packed.append('\x00' * 6)
        packed.append(struct.pack("!256s", self.err_str))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = insblock_failed_error_msg()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 1)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        _err_type = reader.read("!H")[0]
        assert(_err_type == 16)
        obj.code = reader.read("!H")[0]
        obj.device_id = reader.read("!L")[0]
        obj.slotID = reader.read("!H")[0]
        reader.skip(6)
        obj.err_str = reader.read("!256s")[0].rstrip("\x00")
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.code != other.code: return False
        if self.device_id != other.device_id: return False
        if self.slotID != other.slotID: return False
        if self.err_str != other.err_str: return False
        return True

    def pretty_print(self, q):
        q.text("insblock_failed_error_msg {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("code = ");
                q.text("%#x" % self.code)
                q.text(","); q.breakable()
                q.text("device_id = ");
                q.text("%#x" % self.device_id)
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(","); q.breakable()
                q.text("err_str = ");
                q.pp(self.err_str)
            q.breakable()
        q.text('}')

error_msg.subtypes[16] = insblock_failed_error_msg
"""
class experimenter_error_msg(error_msg):
    subtypes = {}

    version = 4
    type = 1
    err_type = 65535

    def __init__(self, xid=None, subtype=None, experimenter=None, data=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if subtype != None:
            self.subtype = subtype
        else:
            self.subtype = 0
        if experimenter != None:
            self.experimenter = experimenter
        else:
            self.experimenter = 0
        if data != None:
            self.data = data
        else:
            self.data = ''
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!H", self.err_type))
        packed.append(struct.pack("!H", self.subtype))
        packed.append(struct.pack("!L", self.experimenter))
        packed.append(self.data)
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        subtype, = reader.peek('!H', 10)#?L,12
        subclass = experimenter_error_msg.subtypes.get(subtype)
        if subclass:
            return subclass.unpack(reader)

        obj = experimenter_error_msg()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 1)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        _err_type = reader.read("!H")[0]
        assert(_err_type == 65535)
        obj.subtype = reader.read("!H")[0]
        obj.experimenter = reader.read("!L")[0]
        obj.data = str(reader.read_all())
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.subtype != other.subtype: return False
        if self.experimenter != other.experimenter: return False
        if self.data != other.data: return False
        return True

    def pretty_print(self, q):
        q.text("experimenter_error_msg {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("subtype = ");
                q.text("%#x" % self.subtype)
                q.text(","); q.breakable()
                q.text("data = ");
                q.pp(self.data)
            q.breakable()
        q.text('}')

error_msg.subtypes[65535] = experimenter_error_msg
"""
#-----echo request message, with no body-------------------------------------------

class echo_request(message):
    version = 4
    type = 2

    def __init__(self, xid=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = echo_request()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 2)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        return True

    def pretty_print(self, q):
        q.text("echo_request {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
            q.breakable()
        q.text('}')

message.subtypes[2] = echo_request

#-----echo reply message, with no body---------------------------------------------

class echo_reply(message):
    version = 4
    type = 3

    def __init__(self, xid=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = echo_reply()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 3)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        return True

    def pretty_print(self, q):
        q.text("echo_reply {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
            q.breakable()
        q.text('}')

message.subtypes[3] = echo_reply

#-----experimenter message, pof_switch do not implement----------------------------
'''
class experimenter(message):
    subtypes = {}

    version = 4
    type = 4

    def __init__(self, xid=None, experimenter=None, subtype=None, data=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if experimenter != None:
            self.experimenter = experimenter
        else:
            self.experimenter = 0
        if subtype != None:
            self.subtype = subtype
        else:
            self.subtype = 0
        if data != None:
            self.data = data
        else:
            self.data = ''
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!L", self.experimenter))
        packed.append(struct.pack("!L", self.subtype))
        packed.append(self.data)
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        subtype, = reader.peek('!L', 8)#?L,12
        subclass = experimenter.subtypes.get(subtype)
        if subclass:
            return subclass.unpack(reader)

        obj = experimenter()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 4)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        obj.experimenter = reader.read("!L")[0]
        obj.subtype = reader.read("!L")[0]
        obj.data = str(reader.read_all())
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.experimenter != other.experimenter: return False
        if self.subtype != other.subtype: return False
        if self.data != other.data: return False
        return True

    def pretty_print(self, q):
        q.text("experimenter {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("subtype = ");
                q.text("%#x" % self.subtype)
                q.text(","); q.breakable()
                q.text("data = ");
                q.pp(self.data)
            q.breakable()
        q.text('}')

message.subtypes[4] = experimenter
'''
#-----feature request message, with no body----------------------------------------

class features_request(message):
    version = 4
    type = 5

    def __init__(self, xid=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = features_request()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 5)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        return True

    def pretty_print(self, q):
        q.text("features_request {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
            q.breakable()
        q.text('}')

message.subtypes[5] = features_request

#-----features reply message-------------------------------------------------------

class features_reply(message):
    version = 4
    type = 6

    def __init__(self, xid=None, dev_id=None, slot_id=None, port_num=None, table_num=None, capabilities=None, vendor_id=None, dev_fw_id=None, dev_lkup_id=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if dev_id != None:
            self.dev_id = dev_id
        else:
            self.dev_id = 0
        if slot_id != None:
            self.slot_id = slot_id
        else:
            self.slot_id = 0
        if port_num != None:
            self.port_num = port_num
        else:
            self.port_num = 0
        if table_num != None:
            self.table_num = table_num
        else:
            self.table_num = 0
        if capabilities != None:
            self.capabilities = capabilities
        else:
            self.capabilities = 0
        if vendor_id != None:
            self.vendor_id = vendor_id
        else:
            self.vendor_id = ""
        if dev_fw_id != None:
            self.dev_fw_id = dev_fw_id
        else:
            self.dev_fw_id = ""
        if dev_lkup_id != None:
            self.dev_lkup_id = dev_lkup_id
        else:
            self.dev_lkup_id = ""
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!L", self.dev_id))
        packed.append(struct.pack("!H", self.slot_id))
        packed.append(struct.pack("!H", self.port_num))
        packed.append(struct.pack("!H", self.table_num))
        packed.append('\x00' * 2)
        packed.append(struct.pack("!L", self.capabilities))
        packed.append(struct.pack("!64s", self.vendor_id))
        packed.append(struct.pack("!64s", self.dev_fw_id))
        packed.append(struct.pack("!64s", self.dev_lkup_id))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = features_reply()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 6)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        obj.dev_id = reader.read("!L")[0]
        obj.slot_id = reader.read("!H")[0]
        obj.port_num = reader.read("!H")[0]
        obj.table_num = reader.read("!H")[0]
        reader.skip(2)
        obj.capabilities = reader.read("!L")[0]
        obj.vendor_id = reader.read("!64s")[0].rstrip("\x00")
        obj.dev_fw_id = reader.read("!64s")[0].rstrip("\x00")
        obj.dev_lkup_id = reader.read("!64s")[0].rstrip("\x00")
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.dev_id != other.dev_id: return False
        if self.slot_id != other.slot_id: return False
        if self.port_num != other.port_num: return False
        if self.table_num != other.table_num: return False
        if self.capabilities != other.capabilities: return False
        if self.vendor_id != other.vendor_id: return False
        if self.dev_fw_id != other.dev_fw_id: return False
        if self.dev_lkup_id != other.dev_lkup_id: return False
        return True

    def pretty_print(self, q):
        q.text("features_reply {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("dev_id = ");
                q.text("%#x" % self.dev_id)
                q.text(","); q.breakable()
                q.text("slot_id = ");
                q.text("%#x" % self.slot_id)
                q.text(","); q.breakable()
                q.text("port_num = ");
                q.text("%#x" % self.port_num)
                q.text(","); q.breakable()
                q.text("table_num = ");
                q.text("%#x" % self.table_num)
                q.text(","); q.breakable()
                q.text("capabilities = ");
                q.text("%#x" % self.capabilities)
                q.text(","); q.breakable()
                q.text("vendor_id = ");
                q.pp(self.vendor_id)
                q.text(","); q.breakable()
                q.text("dev_fw_id = ");
                q.pp(self.dev_fw_id)
                q.text(","); q.breakable()
                q.text("dev_lkup_id = ");
                q.pp(self.dev_lkup_id)
            q.breakable()
        q.text('}')

message.subtypes[6] = features_reply

#-----get config request message, with no body-------------------------------------

class get_config_request(message):
    version = 4
    type = 7

    def __init__(self, xid=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = get_config_request()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 7)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        return True

    def pretty_print(self, q):
        q.text("get_config_request {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
            q.breakable()
        q.text('}')

message.subtypes[7] = get_config_request

#-----get config reply message-----------------------------------------------------

class get_config_reply(message):
    version = 4
    type = 8

    def __init__(self, xid=None, dev_id=None, flags=None, miss_send_len=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if dev_id != None:
            self.dev_id = dev_id
        else:
            self.dev_id = 0
        if flags != None:
            self.flags = flags
        else:
            self.flags = 0
        if miss_send_len != None:
            self.miss_send_len = miss_send_len
        else:
            self.miss_send_len = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!L", self.dev_id))
        packed.append(struct.pack("!H", self.flags))
        packed.append(struct.pack("!H", self.miss_send_len))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = get_config_reply()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 8)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        obj.dev_id = reader.read("!L")[0]
        obj.flags = reader.read("!H")[0]
        obj.miss_send_len = reader.read("!H")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.dev_id != other.dev_id: return False
        if self.flags != other.flags: return False
        if self.miss_send_len != other.miss_send_len: return False
        return True

    def pretty_print(self, q):
        q.text("get_config_reply {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("dev_id = ");
                q.text("%#x" % self.dev_id)
                q.text(","); q.breakable()
                q.text("flags = ");
                q.text("%#x" % self.flags)
                q.text(","); q.breakable()
                q.text("miss_send_len = ");
                q.text("%#x" % self.miss_send_len)
            q.breakable()
        q.text('}')

message.subtypes[8] = get_config_reply

#-----set config message--------------------------------------------------------

class set_config(message):
    version = 4
    type = 9

    def __init__(self, xid=None, dev_id=None, flags=None, miss_send_len=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if dev_id != None:
            self.dev_id = dev_id
        else:
            self.dev_id = 0
        if flags != None:
            self.flags = flags
        else:
            self.flags = 0
        if miss_send_len != None:
            self.miss_send_len = miss_send_len
        else:
            self.miss_send_len = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!L", self.dev_id))
        packed.append(struct.pack("!H", self.flags))
        packed.append(struct.pack("!H", self.miss_send_len))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = set_config()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 9)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        obj.dev_id = reader.read("!L")[0]
        obj.flags = reader.read("!H")[0]
        obj.miss_send_len = reader.read("!H")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.dev_id != other.dev_id: return False
        if self.flags != other.flags: return False
        if self.miss_send_len != other.miss_send_len: return False
        return True

    def pretty_print(self, q):
        q.text("set_config {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("dev_id = ");
                q.text("%#x" % self.dev_id)
                q.text(","); q.breakable()
                q.text("flags = ");
                q.text("%#x" % self.flags)
                q.text(","); q.breakable()
                q.text("miss_send_len = ");
                q.text("%#x" % self.miss_send_len)
            q.breakable()
        q.text('}')

message.subtypes[9] = set_config

#-----packet in message----------------------------------------------------------

class packet_in(message):
    version = 4
    type = 10

    def __init__(self, xid=None, buffer_id=None, total_len=None, reason=None, table_id=None, cookie=None, device_id=None, slotID=None, port_id=None, data=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if buffer_id != None:
            self.buffer_id = buffer_id
        else:
            self.buffer_id = 0
        if total_len != None:
            self.total_len = total_len
        else:
            self.total_len = 0
        if reason != None:
            self.reason = reason
        else:
            self.reason = 0
        if table_id != None:
            self.table_id = table_id
        else:
            self.table_id = 0
        if cookie != None:
            self.cookie = cookie
        else:
            self.cookie = 0
        if device_id != None:
            self.device_id = device_id
        else:
            self.device_id = None
        if slotID != None:
            self.slotID= slotID
        else:
            self.slotID = None
        if port_id != None:
            self.port_id = port_id
        else:
            port_id = None
        if data != None:
            self.data = data
        else:
            self.data = ""
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!L", self.buffer_id))
        packed.append(struct.pack("!H", self.total_len))
        packed.append(struct.pack("!B", self.reason))
        packed.append(struct.pack("!B", self.table_id))
        packed.append(struct.pack("!Q", self.cookie))
        packed.append(struct.pack("!L", self.device_id))
        packed.append(struct.pack("!H", self.slotID))
        packed.append(struct.pack("!H", self.port_id))
        packed.append(self.data)
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = packet_in()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 10)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        obj.buffer_id = reader.read("!L")[0]
        obj.total_len = reader.read("!H")[0]
        obj.reason = reader.read("!B")[0]
        obj.table_id = reader.read("!B")[0]
        obj.cookie = reader.read("!Q")[0]
        obj.device_id = reader.read("!L")[0]
        obj.slotID = reader.read("!H")[0]
        obj.port_id = reader.read("!H")[0]
        obj.data = str(reader.read_all())
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.buffer_id != other.buffer_id: return False
        if self.total_len != other.total_len: return False
        if self.reason != other.reason: return False
        if self.table_id != other.table_id: return False
        if self.cookie != other.cookie: return False
        if self.device_id != other.device_id: return False
        if self.slotID != other.slotID: return False
        if self.port_id != other.port_id: return False
        if self.data != other.data: return False
        return True

    def pretty_print(self, q):
        q.text("packet_in {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("buffer_id = ");
                q.text("%#x" % self.buffer_id)
                q.text(","); q.breakable()
                q.text("total_len = ");
                q.text("%#x" % self.total_len)
                q.text(","); q.breakable()
                q.text("reason = ");
                q.text("%#x" % self.reason)
                q.text(","); q.breakable()
                q.text("table_id = ");
                q.text("%#x" % self.table_id)
                q.text(","); q.breakable()
                q.text("cookie = ");
                q.text("%#x" % self.cookie)
                q.text(","); q.breakable()
                q.text("device_id = ");
                q.text("%#x" % self.device_id)
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(","); q.breakable()
                q.text("port_id = ");
                q.text("%#x" % self.port_id)
                q.text(","); q.breakable()
                q.text("data = ");
                q.pp(self.data)
            q.breakable()
        q.text('}')

message.subtypes[10] = packet_in

#-----flow remove message, pofswitch do not implement----------------------
'''
class flow_removed(message):
    version = 4
    type = 11

    def __init__(self, xid=None, cookie=None, priority=None, reason=None, table_id=None, duration_sec=None, duration_nsec=None, idle_timeout=None, hard_timeout=None, packet_count=None, byte_count=None, match=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if cookie != None:
            self.cookie = cookie
        else:
            self.cookie = 0
        if priority != None:
            self.priority = priority
        else:
            self.priority = 0
        if reason != None:
            self.reason = reason
        else:
            self.reason = 0
        if table_id != None:
            self.table_id = table_id
        else:
            self.table_id = 0
        if duration_sec != None:
            self.duration_sec = duration_sec
        else:
            self.duration_sec = 0
        if duration_nsec != None:
            self.duration_nsec = duration_nsec
        else:
            self.duration_nsec = 0
        if idle_timeout != None:
            self.idle_timeout = idle_timeout
        else:
            self.idle_timeout = 0
        if hard_timeout != None:
            self.hard_timeout = hard_timeout
        else:
            self.hard_timeout = 0
        if packet_count != None:
            self.packet_count = packet_count
        else:
            self.packet_count = 0
        if byte_count != None:
            self.byte_count = byte_count
        else:
            self.byte_count = 0
        if match != None:
            self.match = match
        else:
            self.match = ofp.match()
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!Q", self.cookie))
        packed.append(struct.pack("!H", self.priority))
        packed.append(struct.pack("!B", self.reason))
        packed.append(struct.pack("!B", self.table_id))
        packed.append(struct.pack("!L", self.duration_sec))
        packed.append(struct.pack("!L", self.duration_nsec))
        packed.append(struct.pack("!H", self.idle_timeout))
        packed.append(struct.pack("!H", self.hard_timeout))
        packed.append(struct.pack("!Q", self.packet_count))
        packed.append(struct.pack("!Q", self.byte_count))
        packed.append(self.match.pack())
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = flow_removed()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 11)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        obj.cookie = reader.read("!Q")[0]
        obj.priority = reader.read("!H")[0]
        obj.reason = reader.read("!B")[0]
        obj.table_id = reader.read("!B")[0]
        obj.duration_sec = reader.read("!L")[0]
        obj.duration_nsec = reader.read("!L")[0]
        obj.idle_timeout = reader.read("!H")[0]
        obj.hard_timeout = reader.read("!H")[0]
        obj.packet_count = reader.read("!Q")[0]
        obj.byte_count = reader.read("!Q")[0]
        obj.match = ofp.match.unpack(reader)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.cookie != other.cookie: return False
        if self.priority != other.priority: return False
        if self.reason != other.reason: return False
        if self.table_id != other.table_id: return False
        if self.duration_sec != other.duration_sec: return False
        if self.duration_nsec != other.duration_nsec: return False
        if self.idle_timeout != other.idle_timeout: return False
        if self.hard_timeout != other.hard_timeout: return False
        if self.packet_count != other.packet_count: return False
        if self.byte_count != other.byte_count: return False
        if self.match != other.match: return False
        return True

    def pretty_print(self, q):
        q.text("flow_removed {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("cookie = ");
                q.text("%#x" % self.cookie)
                q.text(","); q.breakable()
                q.text("priority = ");
                q.text("%#x" % self.priority)
                q.text(","); q.breakable()
                q.text("reason = ");
                q.text("%#x" % self.reason)
                q.text(","); q.breakable()
                q.text("table_id = ");
                q.text("%#x" % self.table_id)
                q.text(","); q.breakable()
                q.text("duration_sec = ");
                q.text("%#x" % self.duration_sec)
                q.text(","); q.breakable()
                q.text("duration_nsec = ");
                q.text("%#x" % self.duration_nsec)
                q.text(","); q.breakable()
                q.text("idle_timeout = ");
                q.text("%#x" % self.idle_timeout)
                q.text(","); q.breakable()
                q.text("hard_timeout = ");
                q.text("%#x" % self.hard_timeout)
                q.text(","); q.breakable()
                q.text("packet_count = ");
                q.text("%#x" % self.packet_count)
                q.text(","); q.breakable()
                q.text("byte_count = ");
                q.text("%#x" % self.byte_count)
                q.text(","); q.breakable()
                q.text("match = ");
                q.pp(self.match)
            q.breakable()
        q.text('}')

message.subtypes[11] = flow_removed
'''
#-----port status message--------------------------------------------------

class port_status(message):
    version = 4
    type = 12

    def __init__(self, xid=None, reason=None, desc=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if reason != None:
            self.reason = reason
        else:
            self.reason = 0
        if desc != None:
            self.desc = desc
        else:
            self.desc = ofp.port_desc()
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!B", self.reason))
        packed.append('\x00' * 7)
        packed.append(self.desc.pack())
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = port_status()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 12)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        obj.reason = reader.read("!B")[0]
        reader.skip(7)
        obj.desc = ofp.port_desc.unpack(reader)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.reason != other.reason: return False
        if self.desc != other.desc: return False
        return True

    def pretty_print(self, q):
        q.text("port_status {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("reason = ");
                q.text("%#x" % self.reason)
                q.text(","); q.breakable()
                q.text("desc = ");
                q.pp(self.desc)
            q.breakable()
        q.text('}')

message.subtypes[12] = port_status

#-----resource report message----------------------------------------------

class resource_report(message):
    version = 4
    type = 13

    def __init__(self, xid=None, slot_id=None, resourceType=None, counter_num=None, meter_num=None, group_num=None, tab_res_desc=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if resourceType != None:
            self.resourceType = resourceType
        else:
            self.resourceType = None
        if slot_id != None:
            self.slot_id = slot_id
        else:
            self.slot_id = None
        if counter_num != None:
            self.counter_num = counter_num
        else:
            self.counter_num = None
        if  meter_num!= None:
            self.meter_num = meter_num
        else:
            self.meter_num = None
        if  group_num!= None:
            self.group_num = group_num
        else:
            self.group_num = None
        if  tab_res_desc != None:
            self.tab_res_desc = tab_res_desc
        else:
            self.tab_res_desc = ofp.table_resource_desc()
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!B", self.resourceType))
        packed.append('\x00' * 1)
        packed.append(struct.pack("!H", self.slot_id))
        packed.append(struct.pack("!L", self.counter_num))
        packed.append(struct.pack("!L", self.meter_num))
        packed.append(struct.pack("!L", self.group_num))
        packed.append(self.tab_res_desc.pack())
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = resource_report()
        _version = reader.read("!B")[0]
        assert (_version == 4)
        _type = reader.read("!B")[0]
        assert (_type == 13)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        obj.resourceType = reader.read("!B")[0]
        reader.skip(1)
        obj.slot_id = reader.read("!H")[0]
        obj.counter_num = reader.read("!L")[0]
        obj.meter_num = reader.read("!L")[0]
        obj.group_num = reader.read("!L")[0]
        obj.tab_res_desc = ofp.table_resource_desc.unpack(reader)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.resourceType != other.resourceType: return False
        if self.slot_id != other.slot_id: return False
        if self.counter_num != other.counter_num: return False
        if self.meter_num != other.meter_num: return False
        if self.group_num != other.group_num: return False
        if self.tab_res_desc != other.tab_res_desc: return False
        return True

    def pretty_print(self, q):
        q.text("port_status {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(",");
                q.breakable()
                q.text("resourceType = ");
                q.text("%#x" % self.resourceType)
                q.text(",");
                q.breakable()
                q.text("slot_id = ");
                q.text("%#x" % self.slot_id)
                q.text(",");
                q.breakable()
                q.text("counter_num = ");
                q.text("%#x" % self.counter_num)
                q.text(",");
                q.breakable()
                q.text("meter_num = ");
                q.text("%#x" % self.meter_num)
                q.text(",");
                q.breakable()
                q.text("group_num = ");
                q.text("%#x" % self.group_num)
                q.text(",");
                q.breakable()
                q.text("tab_res_desc = ");
                q.pp(self.tab_res_desc)
            q.breakable()
        q.text('}')

message.subtypes[13] = resource_report

#-----packet out message, pofswitch do not implement-----------------------
'''
class packet_out(message):
    version = 4
    type = 14

    def __init__(self, xid=None, buffer_id=None, in_port=None, actions=None, data=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if buffer_id != None:
            self.buffer_id = buffer_id
        else:
            self.buffer_id = 0
        if in_port != None:
            self.in_port = in_port
        else:
            self.in_port = 0
        if actions != None:
            self.actions = actions
        else:
            self.actions = []
        if data != None:
            self.data = data
        else:
            self.data = ''
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!L", self.buffer_id))
        packed.append(util.pack_port_no(self.in_port))
        packed.append(struct.pack("!H", 0)) # placeholder for actions_len at index 6
        packed.append('\x00' * 6)
        packed.append(loxi.generic_util.pack_list(self.actions))
        packed[6] = struct.pack("!H", len(packed[-1]))
        packed.append(self.data)
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = packet_out()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 13)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        obj.buffer_id = reader.read("!L")[0]
        obj.in_port = util.unpack_port_no(reader)
        _actions_len = reader.read("!H")[0]
        reader.skip(6)
        obj.actions = loxi.generic_util.unpack_list(reader.slice(_actions_len), ofp.action.action.unpack)
        obj.data = str(reader.read_all())
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.buffer_id != other.buffer_id: return False
        if self.in_port != other.in_port: return False
        if self.actions != other.actions: return False
        if self.data != other.data: return False
        return True

    def pretty_print(self, q):
        q.text("packet_out {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("buffer_id = ");
                q.text("%#x" % self.buffer_id)
                q.text(","); q.breakable()
                q.text("in_port = ");
                q.text(util.pretty_port(self.in_port))
                q.text(","); q.breakable()
                q.text("actions = ");
                q.pp(self.actions)
                q.text(","); q.breakable()
                q.text("data = ");
                q.pp(self.data)
            q.breakable()
        q.text('}')

message.subtypes[14] = packet_out
'''
#-----flow mod message-----------------------------------------------------

class flow_mod(message):
    subtypes = {}

    version = 4
    type = 15

    def __init__(self, xid=None, command=None,match_field_num=None, instruction_num=None, counter_id=None, cookie=None, cookie_mask=None, table_id=None, table_type=None, idle_timeout=None, hard_timeout=None, priority=None, index=None, slotID=None, match=None, instructions=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if command != None:
            self.command = command
        else:
            self.command = None
        if match_field_num != None:
            self.match_field_num = match_field_num
        else:
            self.match_field_num = 0
        if instruction_num != None:
            self.instruction_num = instruction_num
        else:
            self.instruction_num = 0
        if counter_id != None:
            self.counter_id = counter_id
        else:
            self.counter_id = 0
        if cookie != None:
            self.cookie = cookie
        else:
            self.cookie = 0
        if cookie_mask != None:
            self.cookie = cookie_mask
        else:
            self.cookie_mask = 0
        if table_id != None:
            self.table_id = table_id
        else:
            self.table_id = 0
        if table_type != None:
            self.table_type = table_type
        else:
            self.table_type = None
        if idle_timeout != None:
            self.idle_timeout = idle_timeout
        else:
            self.idle_timeout = 0
        if hard_timeout != None:
            self.hard_timeout = hard_timeout
        else:
            self.hard_timeout = 0
        if priority != None:
            self.priority = priority
        else:
            self.priority = 0
        if index != None:
            self.index = index
        else:
            self.index = 0
        if slotID != None:
            self.slotID = slotID
        else:
            self.slotID = 0
        if match != None:
            self.match = match
        else:
            self.match = []
        if instructions != None:
            self.instructions = instructions
        else:
            self.instructions = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!B", self.command))
        packed.append(struct.pack("!B", self.match_field_num))
        packed.append(struct.pack("!B", self.instruction_num))
        packed.append('\x00' * 1)
        packed.append(struct.pack("!L", self.counter_id))
        packed.append(struct.pack("!Q", self.cookie))
        packed.append(struct.pack("!Q", self.cookie_mask))
        packed.append(struct.pack("!B", self.table_id))
        packed.append(struct.pack("!B", self.table_type))
        packed.append(struct.pack("!H", self.idle_timeout))
        packed.append(struct.pack("!H", self.hard_timeout))
        packed.append(struct.pack("!H", self.priority))
        packed.append(struct.pack("!L", self.index))
        packed.append(struct.pack("!H", self.slotID))
        packed.append('\x00' * 2)
        packed.append(loxi.generic_util.pack_list(self.match))#?how to express the num
        packed.append(loxi.generic_util.pack_list(self.instructions))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        subtype, = reader.peek('B', 8)
        subclass = flow_mod.subtypes.get(subtype)
        if subclass:
            return subclass.unpack(reader)

        obj = flow_mod()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 15)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        obj.command = reader.read("!B")[0]
        obj.match_field_num = reader.read("!B")[0]
        obj.instruction_num = reader.read("!B")[0]
        reader.skip(1)
        obj.counter_id = reader.read("!L")[0]
        obj.cookie = reader.read("!Q")[0]
        obj.cookie_mask = reader.read("!Q")[0]
        obj.table_id = reader.read("!B")[0]
        obj.table_type = reader.read("!B")[0]
        #obj._command = util.unpack_fm_cmd(reader)
        obj.idle_timeout = reader.read("!H")[0]
        obj.hard_timeout = reader.read("!H")[0]
        obj.priority = reader.read("!H")[0]
        obj.index = reader.read("!L")[0]
        obj.slotID = reader.read("!H")[0]
        reader.skip(2)
        obj.match = loxi.generic_util.unpack_list(reader, ofp.match.unpack)
        obj.instructions = loxi.generic_util.unpack_list(reader, ofp.instruction.instruction.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.command != other.command: return False
        if self.match_field_num != other.match_field_num: return False
        if self.instruction_num != other.instruction_num: return False
        if self.counter_id != other.counter_id: return False
        if self.cookie != other.cookie: return False
        if self.cookie_mask != other.cookie_mask: return False
        if self.table_id != other.table_id: return False
        if self.table_type != other.table_type: return False
        if self.idle_timeout != other.idle_timeout: return False
        if self.hard_timeout != other.hard_timeout: return False
        if self.priority != other.priority: return False
        if self.index != other.index: return False
        if self.slotID != other.slotID: return False
        if self.match != other.match: return False
        if self.instructions != other.instructions: return False
        return True

    def pretty_print(self, q):
        q.text("flow_mod {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("command = ")
                q.text("%#x" % self.command)
                q.text(","); q.breakable()
                q.text("match_field_num = ")
                q.text("%#x" % self.match_field_num)
                q.text(","); q.breakable()
                q.text("instruction_num = ")
                q.text("%#x" % self.instruction_num)
                q.text(","); q.breakable()
                q.text("counter_id = ")
                q.text("%#x" % self.counter_id)
                q.text(","); q.breakable()
                q.text("cookie = ");
                q.text("%#x" % self.cookie)
                q.text(","); q.breakable()
                q.text("cookie_mask = ");
                q.text("%#x" % self.cookie_mask)
                q.text(","); q.breakable()
                q.text("table_id = ");
                q.text("%#x" % self.table_id)
                q.text(","); q.breakable()
                q.text("table_type = ")
                q.text("%#x" % self.table_type)
                q.text(","); q.breakable()
                q.text("idle_timeout = ");
                q.text("%#x" % self.idle_timeout)
                q.text(","); q.breakable()
                q.text("hard_timeout = ");
                q.text("%#x" % self.hard_timeout)
                q.text(","); q.breakable()
                q.text("priority = ");
                q.text("%#x" % self.priority)
                q.text(","); q.breakable()
                q.text("index = ");
                q.text("%#x" % self.index)
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(","); q.breakable()
                q.text("match = ");
                q.pp(self.match)
                q.text(","); q.breakable()
                q.text("instructions = ");
                q.pp(self.instructions)
            q.breakable()
        q.text('}')

message.subtypes[15] = flow_mod

class flow_add(flow_mod):
    version = 4
    type = 15
    _command = 0

    def __init__(self, xid=None, match_field_num=None, instruction_num=None, counter_id=None, cookie=None, cookie_mask=None, table_id=None, table_type=None, idle_timeout=None, hard_timeout=None, priority=None, index=None, slotID=None, match=None, instructions=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if match_field_num != None:
            self.match_field_num = match_field_num
        else:
            self.match_field_num = 0
        if instruction_num != None:
            self.instruction_num = instruction_num
        else:
            self.instruction_num = 0
        if counter_id != None:
            self.counter_id = counter_id
        else:
            self.counter_id = 0
        if cookie != None:
            self.cookie = cookie
        else:
            self.cookie = 0
        if cookie_mask != None:
            self.cookie = cookie_mask
        else:
            self.cookie_mask = 0
        if table_id != None:
            self.table_id = table_id
        else:
            self.table_id = 0
        if table_type != None:
            self.table_type = table_type
        else:
            self.table_type = 0
        if idle_timeout != None:
            self.idle_timeout = idle_timeout
        else:
            self.idle_timeout = 0
        if hard_timeout != None:
            self.hard_timeout = hard_timeout
        else:
            self.hard_timeout = 0
        if priority != None:
            self.priority = priority
        else:
            self.priority = 0
        if index != None:
            self.index = index
        else:
            self.index = 0
        if slotID != None:
            self.slotID = slotID
        else:
            self.slotID = 0
        if match != None:
            self.match = match
        else:
            self.match = []
        if instructions != None:
            self.instructions = instructions
        else:
            self.instructions = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(util.pack_fm_cmd(self._command))
        packed.append(struct.pack("!B", self.match_field_num))
        packed.append(struct.pack("!B", self.instruction_num))
        packed.append('\x00' * 1)
        packed.append(struct.pack("!L", self.counter_id))
        packed.append(struct.pack("!Q", self.cookie))
        packed.append(struct.pack("!Q", self.cookie_mask))
        packed.append(struct.pack("!B", self.table_id))
        packed.append(struct.pack("!B", self.table_type))
        packed.append(struct.pack("!H", self.idle_timeout))
        packed.append(struct.pack("!H", self.hard_timeout))
        packed.append(struct.pack("!H", self.priority))
        packed.append(struct.pack("!L", self.index))
        packed.append(struct.pack("!H", self.slotID))
        packed.append('\x00' * 2)
        packed.append(loxi.generic_util.pack_list(self.match))
        if len(self.match) < 8:
            empty_match = [ofp.match_x for i in range(len(self.match), 8)]
            packed.append(loxi.generic_util.pack_list(empty_match))
        elif len(self.match) > 8:
            raise Exception('too much match_x!')
        packed.append(loxi.generic_util.pack_list(self.instructions))
        instructions_len = len(packed[len(packed)-1])
        if instructions_len < 296:
            packed.append('\x00' * (296 - instructions_len))
        elif instructions_len > 296:
            raise Exception('too much len instructions!')
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = flow_add()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 15)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        _command = util.unpack_fm_cmd(reader)
        assert(_command == 0)
        obj.match_field_num = reader.read("!B")[0]
        obj.instruction_num = reader.read("!B")[0]
        reader.skip(1)
        obj.counter_id = reader.read("!L")[0]
        obj.cookie = reader.read("!Q")[0]
        obj.cookie_mask = reader.read("!Q")[0]
        obj.table_id = reader.read("!B")[0]
        obj.table_type = reader.read("!B")[0]
        #obj._command = util.unpack_fm_cmd(reader)
        obj.idle_timeout = reader.read("!H")[0]
        obj.hard_timeout = reader.read("!H")[0]
        obj.priority = reader.read("!H")[0]
        obj.index = reader.read("!L")[0]
        obj.slotID = reader.read("!H")[0]
        reader.skip(2)
        obj.match = loxi.generic_util.unpack_list(reader, ofp.match.unpack)
        obj.instructions = loxi.generic_util.unpack_list(reader, ofp.instruction.instruction.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.match_field_num != other.match_field_num: return False
        if self.instruction_num != other.instruction_num: return False
        if self.counter_id != other.counter_id: return False
        if self.cookie != other.cookie: return False
        if self.cookie_mask != other.cookie_mask: return False
        if self.table_id != other.table_id: return False
        if self.table_type != other.table_type: return False
        if self.idle_timeout != other.idle_timeout: return False
        if self.hard_timeout != other.hard_timeout: return False
        if self.priority != other.priority: return False
        if self.index != other.index: return False
        if self.slotID != other.slotID: return False
        if self.match != other.match: return False
        if self.instructions != other.instructions: return False
        return True

    def pretty_print(self, q):
        q.text("flow_add {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("match_field_num = ")
                q.text("%#x" % self.match_field_num)
                q.text(","); q.breakable()
                q.text("instruction_num = ")
                q.text("%#x" % self.instruction_num)
                q.text(","); q.breakable()
                q.text("counter_id = ")
                q.text("%#x" % self.counter_id)
                q.text(","); q.breakable()
                q.text("cookie = ");
                q.text("%#x" % self.cookie)
                q.text(","); q.breakable()
                q.text("cookie_mask = ");
                q.text("%#x" % self.cookie_mask)
                q.text(","); q.breakable()
                q.text("table_id = ");
                q.text("%#x" % self.table_id)
                q.text(","); q.breakable()
                q.text("table_type = ")
                q.text("%#x" % self.table_type)
                q.text(","); q.breakable()
                q.text("idle_timeout = ");
                q.text("%#x" % self.idle_timeout)
                q.text(","); q.breakable()
                q.text("hard_timeout = ");
                q.text("%#x" % self.hard_timeout)
                q.text(","); q.breakable()
                q.text("priority = ");
                q.text("%#x" % self.priority)
                q.text(","); q.breakable()
                q.text("index = ");
                q.text("%#x" % self.index)
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(","); q.breakable()
                q.text("match = ");
                q.pp(self.match)
                q.text(","); q.breakable()
                q.text("instructions = ");
                q.pp(self.instructions)
            q.breakable()
        q.text('}')

flow_mod.subtypes[0] = flow_add

class flow_modify(flow_mod):
    version = 4
    type = 15
    _command = 1

    def __init__(self, xid=None, match_field_num=None, instruction_num=None, counter_id=None, cookie=None, cookie_mask=None, table_id=None, table_type=None, idle_timeout=None, hard_timeout=None, priority=None, index=None, slotID=None, match=None, instructions=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if match_field_num != None:
            self.match_field_num = match_field_num
        else:
            self.match_field_num = 0
        if instruction_num != None:
            self.instruction_num = instruction_num
        else:
            self.instruction_num = 0
        if counter_id != None:
            self.counter_id = counter_id
        else:
            self.counter_id = 0
        if cookie != None:
            self.cookie = cookie
        else:
            self.cookie = 0
        if cookie_mask != None:
            self.cookie = cookie_mask
        else:
            self.cookie_mask = 0
        if table_id != None:
            self.table_id = table_id
        else:
            self.table_id = 0
        if table_type != None:
            self.table_type = table_type
        else:
            self.table_type = None
        if idle_timeout != None:
            self.idle_timeout = idle_timeout
        else:
            self.idle_timeout = 0
        if hard_timeout != None:
            self.hard_timeout = hard_timeout
        else:
            self.hard_timeout = 0
        if priority != None:
            self.priority = priority
        else:
            self.priority = 0
        if index != None:
            self.index = index
        else:
            self.index = 0
        if slotID != None:
            self.slotID = slotID
        else:
            self.slotID = 0
        if match != None:
            self.match = match
        else:
            self.match = []
        if instructions != None:
            self.instructions = instructions
        else:
            self.instructions = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(util.pack_fm_cmd(self._command))
        packed.append(struct.pack("!B", self.match_field_num))
        packed.append(struct.pack("!B", self.instruction_num))
        packed.append('\x00' * 1)
        packed.append(struct.pack("!L", self.counter_id))
        packed.append(struct.pack("!Q", self.cookie))
        packed.append(struct.pack("!Q", self.cookie_mask))
        packed.append(struct.pack("!B", self.table_id))
        packed.append(struct.pack("!B", self.table_type))
        packed.append(struct.pack("!H", self.idle_timeout))
        packed.append(struct.pack("!H", self.hard_timeout))
        packed.append(struct.pack("!H", self.priority))
        packed.append(struct.pack("!L", self.index))
        packed.append(struct.pack("!H", self.slotID))
        packed.append('\x00' * 2)
        packed.append(loxi.generic_util.pack_list(self.match))#?how to express the num
        packed.append(loxi.generic_util.pack_list(self.instructions))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = flow_modify()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 15)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        _command = util.unpack_fm_cmd(reader)
        assert(_command == 1)
        obj.match_field_num = reader.read("!B")[0]
        obj.instruction_num = reader.read("!B")[0]
        reader.skip(1)
        obj.counter_id = reader.read("!L")[0]
        obj.cookie = reader.read("!Q")[0]
        obj.cookie_mask = reader.read("!Q")[0]
        obj.table_id = reader.read("!B")[0]
        obj.table_type = reader.read("!B")[0]
        #obj._command = util.unpack_fm_cmd(reader)
        obj.idle_timeout = reader.read("!H")[0]
        obj.hard_timeout = reader.read("!H")[0]
        obj.priority = reader.read("!H")[0]
        obj.index = reader.read("!L")[0]
        obj.slotID = reader.read("!H")[0]
        reader.skip(2)
        obj.match = loxi.generic_util.unpack_list(reader, ofp.match.unpack)
        obj.instructions = loxi.generic_util.unpack_list(reader, ofp.instruction.instruction.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.match_field_num != other.match_field_num: return False
        if self.instruction_num != other.instruction_num: return False
        if self.counter_id != other.counter_id: return False
        if self.cookie != other.cookie: return False
        if self.cookie_mask != other.cookie_mask: return False
        if self.table_id != other.table_id: return False
        if self.table_type != other.table_type: return False
        if self.idle_timeout != other.idle_timeout: return False
        if self.hard_timeout != other.hard_timeout: return False
        if self.priority != other.priority: return False
        if self.index != other.index: return False
        if self.slotID != other.slotID: return False
        if self.match != other.match: return False
        if self.instructions != other.instructions: return False
        return True

    def pretty_print(self, q):
        q.text("flow_add {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("match_field_num = ")
                q.text("%#x" % self.match_field_num)
                q.text(","); q.breakable()
                q.text("instruction_num = ")
                q.text("%#x" % self.instruction_num)
                q.text(","); q.breakable()
                q.text("counter_id = ")
                q.text("%#x" % self.counter_id)
                q.text(","); q.breakable()
                q.text("cookie = ");
                q.text("%#x" % self.cookie)
                q.text(","); q.breakable()
                q.text("cookie_mask = ");
                q.text("%#x" % self.cookie_mask)
                q.text(","); q.breakable()
                q.text("table_id = ");
                q.text("%#x" % self.table_id)
                q.text(","); q.breakable()
                q.text("table_type = ")
                q.text("%#x" % self.table_type)
                q.text(","); q.breakable()
                q.text("idle_timeout = ");
                q.text("%#x" % self.idle_timeout)
                q.text(","); q.breakable()
                q.text("hard_timeout = ");
                q.text("%#x" % self.hard_timeout)
                q.text(","); q.breakable()
                q.text("priority = ");
                q.text("%#x" % self.priority)
                q.text(","); q.breakable()
                q.text("index = ");
                q.text("%#x" % self.index)
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(","); q.breakable()
                q.text("match = ");
                q.pp(self.match)
                q.text(","); q.breakable()
                q.text("instructions = ");
                q.pp(self.instructions)
            q.breakable()
        q.text('}')

flow_mod.subtypes[1] = flow_modify

'''---pofswitch do not implement---
class flow_modify_strict(flow_mod):
    version = 4
    type = 15
    _command = 2

    def __init__(self, xid=None, cookie=None, cookie_mask=None, table_id=None, idle_timeout=None, hard_timeout=None, priority=None, buffer_id=None, out_port=None, out_group=None, flags=None, importance=None, match=None, instructions=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if cookie != None:
            self.cookie = cookie
        else:
            self.cookie = 0
        if cookie_mask != None:
            self.cookie_mask = cookie_mask
        else:
            self.cookie_mask = 0
        if table_id != None:
            self.table_id = table_id
        else:
            self.table_id = 0
        if idle_timeout != None:
            self.idle_timeout = idle_timeout
        else:
            self.idle_timeout = 0
        if hard_timeout != None:
            self.hard_timeout = hard_timeout
        else:
            self.hard_timeout = 0
        if priority != None:
            self.priority = priority
        else:
            self.priority = 0
        if buffer_id != None:
            self.buffer_id = buffer_id
        else:
            self.buffer_id = 0
        if out_port != None:
            self.out_port = out_port
        else:
            self.out_port = 0
        if out_group != None:
            self.out_group = out_group
        else:
            self.out_group = 0
        if flags != None:
            self.flags = flags
        else:
            self.flags = 0
        if importance != None:
            self.importance = importance
        else:
            self.importance = 0
        if match != None:
            self.match = match
        else:
            self.match = ofp.match()
        if instructions != None:
            self.instructions = instructions
        else:
            self.instructions = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!Q", self.cookie))
        packed.append(struct.pack("!Q", self.cookie_mask))
        packed.append(struct.pack("!B", self.table_id))
        packed.append(util.pack_fm_cmd(self._command))
        packed.append(struct.pack("!H", self.idle_timeout))
        packed.append(struct.pack("!H", self.hard_timeout))
        packed.append(struct.pack("!H", self.priority))
        packed.append(struct.pack("!L", self.buffer_id))
        packed.append(util.pack_port_no(self.out_port))
        packed.append(struct.pack("!L", self.out_group))
        packed.append(struct.pack("!H", self.flags))
        packed.append(struct.pack("!H", self.importance))
        packed.append(self.match.pack())
        packed.append(loxi.generic_util.pack_list(self.instructions))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = flow_modify_strict()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 14)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        obj.cookie = reader.read("!Q")[0]
        obj.cookie_mask = reader.read("!Q")[0]
        obj.table_id = reader.read("!B")[0]
        __command = util.unpack_fm_cmd(reader)
        assert(__command == 2)
        obj.idle_timeout = reader.read("!H")[0]
        obj.hard_timeout = reader.read("!H")[0]
        obj.priority = reader.read("!H")[0]
        obj.buffer_id = reader.read("!L")[0]
        obj.out_port = util.unpack_port_no(reader)
        obj.out_group = reader.read("!L")[0]
        obj.flags = reader.read("!H")[0]
        obj.importance = reader.read("!H")[0]
        obj.match = ofp.match.unpack(reader)
        obj.instructions = loxi.generic_util.unpack_list(reader, ofp.instruction.instruction.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.cookie != other.cookie: return False
        if self.cookie_mask != other.cookie_mask: return False
        if self.table_id != other.table_id: return False
        if self.idle_timeout != other.idle_timeout: return False
        if self.hard_timeout != other.hard_timeout: return False
        if self.priority != other.priority: return False
        if self.buffer_id != other.buffer_id: return False
        if self.out_port != other.out_port: return False
        if self.out_group != other.out_group: return False
        if self.flags != other.flags: return False
        if self.importance != other.importance: return False
        if self.match != other.match: return False
        if self.instructions != other.instructions: return False
        return True

    def pretty_print(self, q):
        q.text("flow_modify_strict {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("cookie = ");
                q.text("%#x" % self.cookie)
                q.text(","); q.breakable()
                q.text("cookie_mask = ");
                q.text("%#x" % self.cookie_mask)
                q.text(","); q.breakable()
                q.text("table_id = ");
                q.text("%#x" % self.table_id)
                q.text(","); q.breakable()
                q.text("idle_timeout = ");
                q.text("%#x" % self.idle_timeout)
                q.text(","); q.breakable()
                q.text("hard_timeout = ");
                q.text("%#x" % self.hard_timeout)
                q.text(","); q.breakable()
                q.text("priority = ");
                q.text("%#x" % self.priority)
                q.text(","); q.breakable()
                q.text("buffer_id = ");
                q.text("%#x" % self.buffer_id)
                q.text(","); q.breakable()
                q.text("out_port = ");
                q.text(util.pretty_port(self.out_port))
                q.text(","); q.breakable()
                q.text("out_group = ");
                q.text("%#x" % self.out_group)
                q.text(","); q.breakable()
                q.text("flags = ");
                q.text("%#x" % self.flags)
                q.text(","); q.breakable()
                q.text("importance = ");
                q.text("%#x" % self.importance)
                q.text(","); q.breakable()
                q.text("match = ");
                q.pp(self.match)
                q.text(","); q.breakable()
                q.text("instructions = ");
                q.pp(self.instructions)
            q.breakable()
        q.text('}')

flow_mod.subtypes[2] = flow_modify_strict
'''
class flow_delete(flow_mod):
    version = 4
    type = 15
    _command = 3

    def __init__(self, xid=None, match_field_num=None, instruction_num=None, counter_id=None, cookie=None, cookie_mask=None, table_id=None, table_type=None, idle_timeout=None, hard_timeout=None, priority=None, index=None, slotID=None, match=None, instructions=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if match_field_num != None:
            self.match_field_num = match_field_num
        else:
            self.match_field_num = 0
        if instruction_num != None:
            self.instruction_num = instruction_num
        else:
            self.instruction_num = 0
        if counter_id != None:
            self.counter_id = counter_id
        else:
            self.counter_id = 0
        if cookie != None:
            self.cookie = cookie
        else:
            self.cookie = 0
        if cookie_mask != None:
            self.cookie = cookie_mask
        else:
            self.cookie_mask = 0
        if table_id != None:
            self.table_id = table_id
        else:
            self.table_id = 0
        if table_type != None:
            self.table_type = table_type
        else:
            self.table_type = None
        if idle_timeout != None:
            self.idle_timeout = idle_timeout
        else:
            self.idle_timeout = 0
        if hard_timeout != None:
            self.hard_timeout = hard_timeout
        else:
            self.hard_timeout = 0
        if priority != None:
            self.priority = priority
        else:
            self.priority = 0
        if index != None:
            self.index = index
        else:
            self.index = 0
        if slotID != None:
            self.slotID = slotID
        else:
            self.slotID = 0
        if match != None:
            self.match = match
        else:
            self.match = []
        if instructions != None:
            self.instructions = instructions
        else:
            self.instructions = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(util.pack_fm_cmd(self._command))
        packed.append(struct.pack("!B", self.match_field_num))
        packed.append(struct.pack("!B", self.instruction_num))
        packed.append('\x00' * 1)
        packed.append(struct.pack("!L", self.counter_id))
        packed.append(struct.pack("!Q", self.cookie))
        packed.append(struct.pack("!Q", self.cookie_mask))
        packed.append(struct.pack("!B", self.table_id))
        packed.append(struct.pack("!B", self.table_type))
        packed.append(struct.pack("!H", self.idle_timeout))
        packed.append(struct.pack("!H", self.hard_timeout))
        packed.append(struct.pack("!H", self.priority))
        packed.append(struct.pack("!L", self.index))
        packed.append(struct.pack("!H", self.slotID))
        packed.append('\x00' * 2)
        packed.append(loxi.generic_util.pack_list(self.match))#?how to express the num
        packed.append(loxi.generic_util.pack_list(self.instructions))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = flow_delete()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 15)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        _command = util.unpack_fm_cmd(reader)
        assert(_command == 3)
        obj.match_field_num = reader.read("!B")[0]
        obj.instruction_num = reader.read("!B")[0]
        reader.skip(1)
        obj.counter_id = reader.read("!L")[0]
        obj.cookie = reader.read("!Q")[0]
        obj.cookie_mask = reader.read("!Q")[0]
        obj.table_id = reader.read("!B")[0]
        obj.table_type = reader.read("!B")[0]
        #obj._command = util.unpack_fm_cmd(reader)
        obj.idle_timeout = reader.read("!H")[0]
        obj.hard_timeout = reader.read("!H")[0]
        obj.priority = reader.read("!H")[0]
        obj.index = reader.read("!L")[0]
        obj.slotID = reader.read("!H")[0]
        reader.skip(2)
        obj.match = loxi.generic_util.unpack_list(reader, ofp.match.unpack)
        obj.instructions = loxi.generic_util.unpack_list(reader, ofp.instruction.instruction.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.match_field_num != other.match_field_num: return False
        if self.instruction_num != other.instruction_num: return False
        if self.counter_id != other.counter_id: return False
        if self.cookie != other.cookie: return False
        if self.cookie_mask != other.cookie_mask: return False
        if self.table_id != other.table_id: return False
        if self.table_type != other.table_type: return False
        if self.idle_timeout != other.idle_timeout: return False
        if self.hard_timeout != other.hard_timeout: return False
        if self.priority != other.priority: return False
        if self.index != other.index: return False
        if self.slotID != other.slotID: return False
        if self.match != other.match: return False
        if self.instructions != other.instructions: return False
        return True

    def pretty_print(self, q):
        q.text("flow_add {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("match_field_num = ")
                q.text("%#x" % self.match_field_num)
                q.text(","); q.breakable()
                q.text("instruction_num = ")
                q.text("%#x" % self.instruction_num)
                q.text(","); q.breakable()
                q.text("counter_id = ")
                q.text("%#x" % self.counter_id)
                q.text(","); q.breakable()
                q.text("cookie = ");
                q.text("%#x" % self.cookie)
                q.text(","); q.breakable()
                q.text("cookie_mask = ");
                q.text("%#x" % self.cookie_mask)
                q.text(","); q.breakable()
                q.text("table_id = ");
                q.text("%#x" % self.table_id)
                q.text(","); q.breakable()
                q.text("table_type = ")
                q.text("%#x" % self.table_type)
                q.text(","); q.breakable()
                q.text("idle_timeout = ");
                q.text("%#x" % self.idle_timeout)
                q.text(","); q.breakable()
                q.text("hard_timeout = ");
                q.text("%#x" % self.hard_timeout)
                q.text(","); q.breakable()
                q.text("priority = ");
                q.text("%#x" % self.priority)
                q.text(","); q.breakable()
                q.text("index = ");
                q.text("%#x" % self.index)
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(","); q.breakable()
                q.text("match = ");
                q.pp(self.match)
                q.text(","); q.breakable()
                q.text("instructions = ");
                q.pp(self.instructions)
            q.breakable()
        q.text('}')

flow_mod.subtypes[3] = flow_delete

'''---pofswitch do not implement---
class flow_delete_strict(flow_mod):
    version = 4
    type = 15
    _command = 4

    def __init__(self, xid=None, cookie=None, cookie_mask=None, table_id=None, idle_timeout=None, hard_timeout=None, priority=None, buffer_id=None, out_port=None, out_group=None, flags=None, importance=None, match=None, instructions=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if cookie != None:
            self.cookie = cookie
        else:
            self.cookie = 0
        if cookie_mask != None:
            self.cookie_mask = cookie_mask
        else:
            self.cookie_mask = 0
        if table_id != None:
            self.table_id = table_id
        else:
            self.table_id = 0
        if idle_timeout != None:
            self.idle_timeout = idle_timeout
        else:
            self.idle_timeout = 0
        if hard_timeout != None:
            self.hard_timeout = hard_timeout
        else:
            self.hard_timeout = 0
        if priority != None:
            self.priority = priority
        else:
            self.priority = 0
        if buffer_id != None:
            self.buffer_id = buffer_id
        else:
            self.buffer_id = 0
        if out_port != None:
            self.out_port = out_port
        else:
            self.out_port = 0
        if out_group != None:
            self.out_group = out_group
        else:
            self.out_group = 0
        if flags != None:
            self.flags = flags
        else:
            self.flags = 0
        if importance != None:
            self.importance = importance
        else:
            self.importance = 0
        if match != None:
            self.match = match
        else:
            self.match = ofp.match()
        if instructions != None:
            self.instructions = instructions
        else:
            self.instructions = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!Q", self.cookie))
        packed.append(struct.pack("!Q", self.cookie_mask))
        packed.append(struct.pack("!B", self.table_id))
        packed.append(util.pack_fm_cmd(self._command))
        packed.append(struct.pack("!H", self.idle_timeout))
        packed.append(struct.pack("!H", self.hard_timeout))
        packed.append(struct.pack("!H", self.priority))
        packed.append(struct.pack("!L", self.buffer_id))
        packed.append(util.pack_port_no(self.out_port))
        packed.append(struct.pack("!L", self.out_group))
        packed.append(struct.pack("!H", self.flags))
        packed.append(struct.pack("!H", self.importance))
        packed.append(self.match.pack())
        packed.append(loxi.generic_util.pack_list(self.instructions))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = flow_delete_strict()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 14)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        obj.cookie = reader.read("!Q")[0]
        obj.cookie_mask = reader.read("!Q")[0]
        obj.table_id = reader.read("!B")[0]
        __command = util.unpack_fm_cmd(reader)
        assert(__command == 4)
        obj.idle_timeout = reader.read("!H")[0]
        obj.hard_timeout = reader.read("!H")[0]
        obj.priority = reader.read("!H")[0]
        obj.buffer_id = reader.read("!L")[0]
        obj.out_port = util.unpack_port_no(reader)
        obj.out_group = reader.read("!L")[0]
        obj.flags = reader.read("!H")[0]
        obj.importance = reader.read("!H")[0]
        obj.match = ofp.match.unpack(reader)
        obj.instructions = loxi.generic_util.unpack_list(reader, ofp.instruction.instruction.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.cookie != other.cookie: return False
        if self.cookie_mask != other.cookie_mask: return False
        if self.table_id != other.table_id: return False
        if self.idle_timeout != other.idle_timeout: return False
        if self.hard_timeout != other.hard_timeout: return False
        if self.priority != other.priority: return False
        if self.buffer_id != other.buffer_id: return False
        if self.out_port != other.out_port: return False
        if self.out_group != other.out_group: return False
        if self.flags != other.flags: return False
        if self.importance != other.importance: return False
        if self.match != other.match: return False
        if self.instructions != other.instructions: return False
        return True

    def pretty_print(self, q):
        q.text("flow_delete_strict {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("cookie = ");
                q.text("%#x" % self.cookie)
                q.text(","); q.breakable()
                q.text("cookie_mask = ");
                q.text("%#x" % self.cookie_mask)
                q.text(","); q.breakable()
                q.text("table_id = ");
                q.text("%#x" % self.table_id)
                q.text(","); q.breakable()
                q.text("idle_timeout = ");
                q.text("%#x" % self.idle_timeout)
                q.text(","); q.breakable()
                q.text("hard_timeout = ");
                q.text("%#x" % self.hard_timeout)
                q.text(","); q.breakable()
                q.text("priority = ");
                q.text("%#x" % self.priority)
                q.text(","); q.breakable()
                q.text("buffer_id = ");
                q.text("%#x" % self.buffer_id)
                q.text(","); q.breakable()
                q.text("out_port = ");
                q.text(util.pretty_port(self.out_port))
                q.text(","); q.breakable()
                q.text("out_group = ");
                q.text("%#x" % self.out_group)
                q.text(","); q.breakable()
                q.text("flags = ");
                q.text("%#x" % self.flags)
                q.text(","); q.breakable()
                q.text("importance = ");
                q.text("%#x" % self.importance)
                q.text(","); q.breakable()
                q.text("match = ");
                q.pp(self.match)
                q.text(","); q.breakable()
                q.text("instructions = ");
                q.pp(self.instructions)
            q.breakable()
        q.text('}')

flow_mod.subtypes[4] = flow_delete_strict
'''

#-----group mod message----------------------------------------------------

class group_mod(message):
    subtypes = {}

    version = 4
    type = 16

    def __init__(self, xid=None, command=None, group_type=None, action_num=None, group_id=None, counter_id=None, slotID=None, action=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if command != None:
            self.command = command
        else:
            self.command = 0
        if group_type != None:
            self.group_type = group_type
        else:
            self.group_type = 0
        if action_num != None:
            self.action_num = action_num
        else:
            self.action_num = 0
        if group_id != None:
            self.group_id = group_id
        else:
            self.group_id = 0
        if counter_id != None:
            self.counter_id = counter_id
        else:
            self.counter_id = 0
        if slotID != None:
            self.soltID = slotID
        else:
            self.soltID = 0
        if action != None:
            self.action = action
        else:
            self.action = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!B", self.command))
        packed.append(struct.pack("!B", self.group_type))
        packed.append(struct.pack("!B", self.action_num))
        packed.append('\x00' * 1)
        packed.append(struct.pack("!L", self.group_id))
        packed.append(struct.pack("!L", self.counter_id))
        packed.append(struct.pack("!H", self.soltID))
        packed.append('\x00' * 2)
        packed.append(loxi.generic_util.pack_list(self.action))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        subtype, = reader.peek('!H', 8)
        subclass = group_mod.subtypes.get(subtype)
        if subclass:
            return subclass.unpack(reader)

        obj = group_mod()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 16)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        obj.command = reader.read("!B")[0]
        obj.group_type = reader.read("!B")[0]
        obj.action_num = reader.read("!B")[0]
        reader.skip(1)
        obj.group_id = reader.read("!L")[0]
        obj.counter_id = reader.read("!L")[0]
        obj.soltID = reader.read("!H")[0]
        reader.skip(2)
        obj.action = loxi.generic_util.unpack_list(reader, ofp.action.action.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.command != other.command: return False
        if self.group_type != other.group_type: return False
        if self.action_num != other.action_num: return False
        if self.group_id != other.group_id: return False
        if self.counter_id != other.couner_id: return False
        if self.soltID != other.soltID: return False
        if self.action != other.action: return False
        return True

    def pretty_print(self, q):
        q.text("group_mod {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("command = ");
                q.text("%#x" % self.command)
                q.text(","); q.breakable()
                q.text("group_type = ");
                q.text("%#x" % self.group_type)
                q.text(","); q.breakable()
                q.text("action_num = ");
                q.text("%#x" % self.action_num)
                q.text(","); q.breakable()
                q.text("group_id = ");
                q.text("%#x" % self.group_id)
                q.text(","); q.breakable()
                q.text("counter_id = ");
                q.text("%#x" % self.counter_id)
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(","); q.breakable()
                q.text("action = ");
                q.pp(self.action)
            q.breakable()
        q.text('}')

message.subtypes[16] = group_mod

class group_add(group_mod):
    version = 4
    type = 16
    command = 0

    def __init__(self, xid=None, group_type=None, action_num=None, group_id=None, counter_id=None, slotID=None, action=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if group_type != None:
            self.group_type = group_type
        else:
            self.group_type = 0
        if action_num != None:
            self.action_num = action_num
        else:
            self.action_num = 0
        if group_id != None:
            self.group_id = group_id
        else:
            self.group_id = 0
        if counter_id != None:
            self.counter_id = counter_id
        else:
            self.counter_id = 0
        if slotID != None:
            self.soltID = slotID
        else:
            self.soltID = 0
        if action != None:
            self.action = action
        else:
            self.action = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!B", self.command))
        packed.append(struct.pack("!B", self.group_type))
        packed.append(struct.pack("!B", self.action_num))
        packed.append('\x00' * 1)
        packed.append(struct.pack("!L", self.group_id))
        packed.append(struct.pack("!L", self.counter_id))
        packed.append(struct.pack("!H", self.soltID))
        packed.append('\x00' * 2)
        packed.append(loxi.generic_util.pack_list(self.action))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = group_add()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 16)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        _command = reader.read("!B")[0]
        assert(_command == 0)
        obj.group_type = reader.read("!B")[0]
        obj.action_num = reader.read("!B")[0]
        reader.skip(1)
        obj.group_id = reader.read("!L")[0]
        obj.counter_id = reader.read("!L")[0]
        obj.soltID = reader.read("!H")[0]
        reader.skip(2)
        obj.action = loxi.generic_util.unpack_list(reader, ofp.action.action.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.group_type != other.group_type: return False
        if self.action_num != other.action_num: return False
        if self.group_id != other.group_id: return False
        if self.counter_id != other.couner_id: return False
        if self.soltID != other.soltID: return False
        if self.action != other.action: return False
        return True

    def pretty_print(self, q):
        q.text("group_add {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("group_type = ");
                q.text("%#x" % self.group_type)
                q.text(","); q.breakable()
                q.text("action_num = ");
                q.text("%#x" % self.action_num)
                q.text(","); q.breakable()
                q.text("group_id = ");
                q.text("%#x" % self.group_id)
                q.text(","); q.breakable()
                q.text("counter_id = ");
                q.text("%#x" % self.counter_id)
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(","); q.breakable()
                q.text("action = ");
                q.pp(self.action)
            q.breakable()
        q.text('}')

group_mod.subtypes[0] = group_add

class group_modify(group_mod):
    version = 4
    type = 16
    command = 1

    def __init__(self, xid=None, group_type=None, action_num=None, group_id=None, counter_id=None, slotID=None, action=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if group_type != None:
            self.group_type = group_type
        else:
            self.group_type = 0
        if action_num != None:
            self.action_num = action_num
        else:
            self.action_num = 0
        if group_id != None:
            self.group_id = group_id
        else:
            self.group_id = 0
        if counter_id != None:
            self.counter_id = counter_id
        else:
            self.counter_id = 0
        if slotID != None:
            self.soltID = slotID
        else:
            self.soltID = 0
        if action != None:
            self.action = action
        else:
            self.action = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!B", self.command))
        packed.append(struct.pack("!B", self.group_type))
        packed.append(struct.pack("!B", self.action_num))
        packed.append('\x00' * 1)
        packed.append(struct.pack("!L", self.group_id))
        packed.append(struct.pack("!L", self.counter_id))
        packed.append(struct.pack("!H", self.soltID))
        packed.append('\x00' * 2)
        packed.append(loxi.generic_util.pack_list(self.action))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = group_modify()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 16)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        _command = reader.read("!B")[0]
        assert(_command == 1)
        obj.group_type = reader.read("!B")[0]
        obj.action_num = reader.read("!B")[0]
        reader.skip(1)
        obj.group_id = reader.read("!L")[0]
        obj.counter_id = reader.read("!L")[0]
        obj.soltID = reader.read("!H")[0]
        reader.skip(2)
        obj.action = loxi.generic_util.unpack_list(reader, ofp.action.action.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.group_type != other.group_type: return False
        if self.action_num != other.action_num: return False
        if self.group_id != other.group_id: return False
        if self.counter_id != other.couner_id: return False
        if self.soltID != other.soltID: return False
        if self.action != other.action: return False
        return True

    def pretty_print(self, q):
        q.text("group_modify {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("group_type = ");
                q.text("%#x" % self.group_type)
                q.text(","); q.breakable()
                q.text("action_num = ");
                q.text("%#x" % self.action_num)
                q.text(","); q.breakable()
                q.text("group_id = ");
                q.text("%#x" % self.group_id)
                q.text(","); q.breakable()
                q.text("counter_id = ");
                q.text("%#x" % self.counter_id)
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(","); q.breakable()
                q.text("action = ");
                q.pp(self.action)
            q.breakable()
        q.text('}')

group_mod.subtypes[1] = group_modify

class group_delete(group_mod):
    version = 4
    type = 16
    command = 2

    def __init__(self, xid=None, group_type=None, action_num=None, group_id=None, counter_id=None, slotID=None, action=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if group_type != None:
            self.group_type = group_type
        else:
            self.group_type = 0
        if action_num != None:
            self.action_num = action_num
        else:
            self.action_num = 0
        if group_id != None:
            self.group_id = group_id
        else:
            self.group_id = 0
        if counter_id != None:
            self.counter_id = counter_id
        else:
            self.counter_id = 0
        if slotID != None:
            self.soltID = slotID
        else:
            self.soltID = 0
        if action != None:
            self.action = action
        else:
            self.action = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!B", self.command))
        packed.append(struct.pack("!B", self.group_type))
        packed.append(struct.pack("!B", self.action_num))
        packed.append('\x00' * 1)
        packed.append(struct.pack("!L", self.group_id))
        packed.append(struct.pack("!L", self.counter_id))
        packed.append(struct.pack("!H", self.soltID))
        packed.append('\x00' * 2)
        packed.append(loxi.generic_util.pack_list(self.action))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = group_delete()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 16)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        _command = reader.read("!B")[0]
        assert(_command == 2)
        obj.group_type = reader.read("!B")[0]
        obj.action_num = reader.read("!B")[0]
        reader.skip(1)
        obj.group_id = reader.read("!L")[0]
        obj.counter_id = reader.read("!L")[0]
        obj.soltID = reader.read("!H")[0]
        reader.skip(2)
        obj.action = loxi.generic_util.unpack_list(reader, ofp.action.action.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.group_type != other.group_type: return False
        if self.action_num != other.action_num: return False
        if self.group_id != other.group_id: return False
        if self.counter_id != other.couner_id: return False
        if self.soltID != other.soltID: return False
        if self.action != other.action: return False
        return True

    def pretty_print(self, q):
        q.text("group_delete {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("group_type = ");
                q.text("%#x" % self.group_type)
                q.text(","); q.breakable()
                q.text("action_num = ");
                q.text("%#x" % self.action_num)
                q.text(","); q.breakable()
                q.text("group_id = ");
                q.text("%#x" % self.group_id)
                q.text(","); q.breakable()
                q.text("counter_id = ");
                q.text("%#x" % self.counter_id)
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(","); q.breakable()
                q.text("action = ");
                q.pp(self.action)
            q.breakable()
        q.text('}')

group_mod.subtypes[2] = group_delete

#-----port mod message-----------------------------------------------------

class port_mod(message):
    version = 4
    type = 17

    def __init__(self, xid=None, reason=None, desc=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if reason != None:
            self.reason = reason
        else:
            self.reason = 0
        if desc != None:
            self.desc = desc
        else:
            self.desc = ofp.port_desc()
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!B", self.reason))
        packed.append('\x00' * 7)
        packed.append(self.desc.pack())
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = port_mod()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 17)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        obj.reason = reaser.read("!B")[0]
        reader.skip(7)
        obj.desc = ofp.port_desc.unpack(reader)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.reason != other.reason: return False
        if self.desc != other.desc: return False
        return True

    def pretty_print(self, q):
        q.text("port_mod {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("reason = ");
                q.text("%#x" % self.reason)
                q.text(","); q.breakable()
                q.text("desc = ");
                q.pp(self.desc)
            q.breakable()
        q.text('}')

message.subtypes[17] = port_mod

#-----table mod message----------------------------------------------------

class table_mod(message):
    subtypes = {}

    version = 4
    type = 18

    def __init__(self, xid=None, command=None, table_id=None, table_type=None, match_field_num=None, size=None, key_len=None, slotID=None, table_name=None, match=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if command != None:
            self.command = command
        else:
            self.command = 0
        if table_id != None:
            self.table_id = table_id
        else:
            self.table_id = 0
        if table_type != None:
            self.table_type = table_type
        else:
            self.table_type = 0
        if match_field_num != None:
            self.match_field_num = match_field_num
        else:
            self.match_field_num = 0
        if size != None:
            self.size = size
        else:
            self.size = 0
        if key_len != None:
            self.key_len = key_len
        else:
            self.key_len = 0
        if slotID != None:
            self.slotID = slotID
        else:
            self.slotID = 0
        if table_name != None:
            self.table_name = table_name
        else:
            self.table_name = ""
        if match != None:
            self.match = match
        else:
            self.match = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!B", self.command))
        packed.append(struct.pack("!B", self.table_id))
        packed.append(struct.pack("!B", self.table_type))
        packed.append(struct.pack("!B", self.match_field_num))
        packed.append(struct.pack("!L", self.size))
        packed.append(struct.pack("!H", self.key_len))
        packed.append(struct.pack("!H", self.slotID))
        packed.append('\x00' * 4)
        packed.append(struct.pack("!64s", self.table_name))
        packed.append(loxi.generic_util.pack_list(self.match))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = table_mod()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 18)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        obj.command = reader.read("!B")[0]
        obj.table_id = reader.read("!B")[0]
        obj.table_type = reader.read("!B")[0]
        obj.match_field_num = reader.read("!B")[0]
        obj.size = reader.read("!L")[0]
        obj.key_len = reader.read("!H")[0]
        obj.slotID = reader.read("!H")[0]
        reader.skip(4)
        obj.config = reader.read("!L")[0]
        obj.table_name = reader.read("!64s")[0].rstrip("\x00")
        obj.match = loxi.generic_util.unpack_list(reader, ofp.match.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.command != other.command: return False
        if self.table_id != other.table_id: return False
        if self.table_type != other.table_type: return False
        if self.match_field_num != other.match_field_num: return False
        if self.size != other.size: return False
        if self.key_len != other.key_len: return False
        if self.slotID != other.soltID: return False
        if self.table_name != other.table_name: return False
        if self.match != other.match: return False
        return True

    def pretty_print(self, q):
        q.text("table_mod {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("command = ");
                q.text("%#x" % self.command)
                q.text(","); q.breakable()
                q.text("table_id = ");
                q.text("%#x" % self.table_id)
                q.text(","); q.breakable()
                q.text("table_type = ");
                q.text("%#x" % self.table_type)
                q.text(","); q.breakable()
                q.text("match_field_num = ");
                q.text("%#x" % self.match_field_num)
                q.text(","); q.breakable()
                q.text("size = ");
                q.text("%#x" % self.size)
                q.text(","); q.breakable()
                q.text("key_len = ");
                q.text("%#x" % self.key_len)
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(","); q.breakable()
                q.text("table_name = ");
                q.pp(self.table_name)
                q.text(","); q.breakable()
                q.text("match = ");
                q.pp(self.match)
            q.breakable()
        q.text('}')

message.subtypes[18] = table_mod

class table_mod(message):
    subtypes = {}

    version = 4
    type = 18

    def __init__(self, xid=None, command=None, table_id=None, table_type=None, match_field_num=None, size=None, key_len=None, slotID=None, table_name=None, match=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if command != None:
            self.command = command
        else:
            self.command = 0
        if table_id != None:
            self.table_id = table_id
        else:
            self.table_id = 0
        if table_type != None:
            self.table_type = table_type
        else:
            self.table_type = 0
        if match_field_num != None:
            self.match_field_num = match_field_num
        else:
            self.match_field_num = 0
        if size != None:
            self.size = size
        else:
            self.size = 0
        if key_len != None:
            self.key_len = key_len
        else:
            self.key_len = 0
        if slotID != None:
            self.slotID = slotID
        else:
            self.slotID = 0
        if table_name != None:
            self.table_name = table_name
        else:
            self.table_name = ""
        if match != None:
            self.match = match
        else:
            self.match = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!B", self.command))
        packed.append(struct.pack("!B", self.table_id))
        packed.append(struct.pack("!B", self.table_type))
        packed.append(struct.pack("!B", self.match_field_num))
        packed.append(struct.pack("!L", self.size))
        packed.append(struct.pack("!H", self.key_len))
        packed.append(struct.pack("!H", self.slotID))
        packed.append('\x00' * 4)
        packed.append(struct.pack("!64s", self.table_name))
        packed.append(loxi.generic_util.pack_list(self.match))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        subtype, = reader.peek('!H', 8)
        subclass = table_mod.subtypes.get(subtype)
        if subclass:
            return subclass.unpack(reader)

        obj = table_mod()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 18)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        obj.command = reader.read("!B")[0]
        obj.table_id = reader.read("!B")[0]
        obj.table_type = reader.read("!B")[0]
        obj.match_field_num = reader.read("!B")[0]
        obj.size = reader.read("!L")[0]
        obj.key_len = reader.read("!H")[0]
        obj.slotID = reader.read("!H")[0]
        reader.skip(4)
        obj.config = reader.read("!L")[0]
        obj.table_name = reader.read("!64s")[0].rstrip("\x00")
        obj.match = loxi.generic_util.unpack_list(reader, ofp.match.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.command != other.command: return False
        if self.table_id != other.table_id: return False
        if self.table_type != other.table_type: return False
        if self.match_field_num != other.match_field_num: return False
        if self.size != other.size: return False
        if self.key_len != other.key_len: return False
        if self.slotID != other.soltID: return False
        if self.table_name != other.table_name: return False
        if self.match != other.match: return False
        return True

    def pretty_print(self, q):
        q.text("table_mod {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("command = ");
                q.text("%#x" % self.command)
                q.text(","); q.breakable()
                q.text("table_id = ");
                q.text("%#x" % self.table_id)
                q.text(","); q.breakable()
                q.text("table_type = ");
                q.text("%#x" % self.table_type)
                q.text(","); q.breakable()
                q.text("match_field_num = ");
                q.text("%#x" % self.match_field_num)
                q.text(","); q.breakable()
                q.text("size = ");
                q.text("%#x" % self.size)
                q.text(","); q.breakable()
                q.text("key_len = ");
                q.text("%#x" % self.key_len)
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(","); q.breakable()
                q.text("table_name = ");
                q.pp(self.table_name)
                q.text(","); q.breakable()
                q.text("match = ");
                q.pp(self.match)
            q.breakable()
        q.text('}')

message.subtypes[18] = table_mod

class table_add(message):
    version = 4
    type = 18
    command = 0
    def __init__(self, xid=None, table_id=None, table_type=None, match_field_num=None, size=None, key_len=None, slotID=None, table_name=None, match=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if table_id != None:
            self.table_id = table_id
        else:
            self.table_id = 0
        if table_type != None:
            self.table_type = table_type
        else:
            self.table_type = 0
        if match_field_num != None:
            self.match_field_num = match_field_num
        else:
            self.match_field_num = 0
        if size != None:
            self.size = size
        else:
            self.size = 0
        if key_len != None:
            self.key_len = key_len
        else:
            self.key_len = 0
        if slotID != None:
            self.slotID = slotID
        else:
            self.slotID = 0
        if table_name != None:
            self.table_name = table_name
        else:
            self.table_name = ""
        if match != None:
            self.match = match
        else:
            self.match = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!B", self.command))
        packed.append(struct.pack("!B", self.table_id))
        packed.append(struct.pack("!B", self.table_type))
        packed.append(struct.pack("!B", self.match_field_num))
        packed.append(struct.pack("!L", self.size))
        packed.append(struct.pack("!H", self.key_len))
        packed.append(struct.pack("!H", self.slotID))
        packed.append('\x00' * 4)
        packed.append(struct.pack("!64s", self.table_name))
        packed.append(loxi.generic_util.pack_list(self.match))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = table_add()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 18)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        _command = reader.read("!B")[0]
        assert(_command == 0)
        obj.table_id = reader.read("!B")[0]
        obj.table_type = reader.read("!B")[0]
        obj.match_field_num = reader.read("!B")[0]
        obj.size = reader.read("!L")[0]
        obj.key_len = reader.read("!H")[0]
        obj.slotID = reader.read("!H")[0]
        reader.skip(4)
        obj.config = reader.read("!L")[0]
        obj.table_name = reader.read("!64s")[0].rstrip("\x00")
        obj.match = loxi.generic_util.unpack_list(reader, ofp.match.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.table_id != other.table_id: return False
        if self.table_type != other.table_type: return False
        if self.match_field_num != other.match_field_num: return False
        if self.size != other.size: return False
        if self.key_len != other.key_len: return False
        if self.slotID != other.soltID: return False
        if self.table_name != other.table_name: return False
        if self.match != other.match: return False
        return True

    def pretty_print(self, q):
        q.text("table_add {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("table_id = ");
                q.text("%#x" % self.table_id)
                q.text(","); q.breakable()
                q.text("table_type = ");
                q.text("%#x" % self.table_type)
                q.text(","); q.breakable()
                q.text("match_field_num = ");
                q.text("%#x" % self.match_field_num)
                q.text(","); q.breakable()
                q.text("size = ");
                q.text("%#x" % self.size)
                q.text(","); q.breakable()
                q.text("key_len = ");
                q.text("%#x" % self.key_len)
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(","); q.breakable()
                q.text("table_name = ");
                q.pp(self.table_name)
                q.text(","); q.breakable()
                q.text("match = ");
                q.pp(self.match)
            q.breakable()
        q.text('}')

table_mod.subtypes[0] = table_add

class table_delete(message):
    version = 4
    type = 18
    command = 2
    def __init__(self, xid=None, table_id=None, table_type=None, match_field_num=None, size=None, key_len=None, slotID=None, table_name=None, match=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if table_id != None:
            self.table_id = table_id
        else:
            self.table_id = 0
        if table_type != None:
            self.table_type = table_type
        else:
            self.table_type = 0
        if match_field_num != None:
            self.match_field_num = match_field_num
        else:
            self.match_field_num = 0
        if size != None:
            self.size = size
        else:
            self.size = 0
        if key_len != None:
            self.key_len = key_len
        else:
            self.key_len = 0
        if slotID != None:
            self.slotID = slotID
        else:
            self.slotID = 0
        if table_name != None:
            self.table_name = table_name
        else:
            self.table_name = ""
        if match != None:
            self.match = match
        else:
            self.match = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!B", self.command))
        packed.append(struct.pack("!B", self.table_id))
        packed.append(struct.pack("!B", self.table_type))
        packed.append(struct.pack("!B", self.match_field_num))
        packed.append(struct.pack("!L", self.size))
        packed.append(struct.pack("!H", self.key_len))
        packed.append(struct.pack("!H", self.slotID))
        packed.append('\x00' * 4)
        packed.append(struct.pack("!64s", self.table_name))
        packed.append(loxi.generic_util.pack_list(self.match))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = table_delete()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 18)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        _command = reader.read("!B")[0]
        assert(_command == 2)
        obj.table_id = reader.read("!B")[0]
        obj.table_type = reader.read("!B")[0]
        obj.match_field_num = reader.read("!B")[0]
        obj.size = reader.read("!L")[0]
        obj.key_len = reader.read("!H")[0]
        obj.slotID = reader.read("!H")[0]
        reader.skip(4)
        obj.config = reader.read("!L")[0]
        obj.table_name = reader.read("!64s")[0].rstrip("\x00")
        obj.match = loxi.generic_util.unpack_list(reader, ofp.match.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.table_id != other.table_id: return False
        if self.table_type != other.table_type: return False
        if self.match_field_num != other.match_field_num: return False
        if self.size != other.size: return False
        if self.key_len != other.key_len: return False
        if self.slotID != other.soltID: return False
        if self.table_name != other.table_name: return False
        if self.match != other.match: return False
        return True

    def pretty_print(self, q):
        q.text("table_delete {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("table_id = ");
                q.text("%#x" % self.table_id)
                q.text(","); q.breakable()
                q.text("table_type = ");
                q.text("%#x" % self.table_type)
                q.text(","); q.breakable()
                q.text("match_field_num = ");
                q.text("%#x" % self.match_field_num)
                q.text(","); q.breakable()
                q.text("size = ");
                q.text("%#x" % self.size)
                q.text(","); q.breakable()
                q.text("key_len = ");
                q.text("%#x" % self.key_len)
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(","); q.breakable()
                q.text("table_name = ");
                q.pp(self.table_name)
                q.text(","); q.breakable()
                q.text("match = ");
                q.pp(self.match)
            q.breakable()
        q.text('}')

table_mod.subtypes[2] = table_delete

#-----multipart request message, pofswitch do not implement----------------

#-----multipart reply message, pofswitch do not implement------------------

#-----barrier request message, pofswitch do not implement------------------
'''
class barrier_request(message):
    version = 4
    type = 21

    def __init__(self, xid=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = barrier_request()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 20)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        return True

    def pretty_print(self, q):
        q.text("barrier_request {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
            q.breakable()
        q.text('}')

message.subtypes[20] = barrier_request
'''
#-----barrier reply message, pofswitch do not implement--------------------
'''
class barrier_reply(message):
    version = 4
    type = 22

    def __init__(self, xid=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = barrier_reply()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 21)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        return True

    def pretty_print(self, q):
        q.text("barrier_reply {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
            q.breakable()
        q.text('}')

message.subtypes[22] = barrier_reply
'''
#-----queue get config request message, pofswitch do not implement---------

#-----queue get config reply message, pofswitch do not implement-----------

#-----role request message, pofswitch do not implement---------------------
'''
class role_request(message):
    version = 4
    type = 25

    def __init__(self, xid=None, role=None, generation_id=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if role != None:
            self.role = role
        else:
            self.role = 0
        if generation_id != None:
            self.generation_id = generation_id
        else:
            self.generation_id = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!L", self.role))
        packed.append('\x00' * 4)
        packed.append(struct.pack("!Q", self.generation_id))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = role_request()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 25)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        obj.role = reader.read("!L")[0]
        reader.skip(4)
        obj.generation_id = reader.read("!Q")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.role != other.role: return False
        if self.generation_id != other.generation_id: return False
        return True

    def pretty_print(self, q):
        q.text("role_request {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("role = ");
                q.text("%#x" % self.role)
                q.text(","); q.breakable()
                q.text("generation_id = ");
                q.text("%#x" % self.generation_id)
            q.breakable()
        q.text('}')

message.subtypes[24] = role_request
'''
#-----role reply message, pofswitch do not implement-----------------------
'''
class role_reply(message):
    version = 4
    type = 26

    def __init__(self, xid=None, role=None, generation_id=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if role != None:
            self.role = role
        else:
            self.role = 0
        if generation_id != None:
            self.generation_id = generation_id
        else:
            self.generation_id = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!L", self.role))
        packed.append('\x00' * 4)
        packed.append(struct.pack("!Q", self.generation_id))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = role_reply()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 26)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        obj.role = reader.read("!L")[0]
        reader.skip(4)
        obj.generation_id = reader.read("!Q")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.role != other.role: return False
        if self.generation_id != other.generation_id: return False
        return True

    def pretty_print(self, q):
        q.text("role_reply {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("role = ");
                q.text("%#x" % self.role)
                q.text(","); q.breakable()
                q.text("generation_id = ");
                q.text("%#x" % self.generation_id)
            q.breakable()
        q.text('}')

message.subtypes[25] = role_reply
'''
#-----get async request message, pofswitch do not implement----------------
'''
class async_get_request(message):
    version = 4
    type = 27

    def __init__(self, xid=None, properties=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if properties != None:
            self.properties = properties
        else:
            self.properties = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(loxi.generic_util.pack_list(self.properties))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = async_get_request()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 27)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        obj.properties = loxi.generic_util.unpack_list(reader, ofp.async_config_prop.async_config_prop.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.properties != other.properties: return False
        return True

    def pretty_print(self, q):
        q.text("async_get_request {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("properties = ");
                q.pp(self.properties)
            q.breakable()
        q.text('}')

message.subtypes[26] = async_get_request
'''
#-----get async reply message, pofswitch do not implement------------------
'''
class async_get_reply(message):
    version = 4
    type = 28

    def __init__(self, xid=None, properties=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if properties != None:
            self.properties = properties
        else:
            self.properties = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(loxi.generic_util.pack_list(self.properties))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = async_get_reply()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 28)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        obj.properties = loxi.generic_util.unpack_list(reader, ofp.async_config_prop.async_config_prop.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.properties != other.properties: return False
        return True

    def pretty_print(self, q):
        q.text("async_get_reply {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("properties = ");
                q.pp(self.properties)
            q.breakable()
        q.text('}')

message.subtypes[27] = async_get_reply
'''
#-----set async message, pofswitch do not implement------------------------
'''
class async_set(message):
    version = 4
    type = 29

    def __init__(self, xid=None, properties=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if properties != None:
            self.properties = properties
        else:
            self.properties = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(loxi.generic_util.pack_list(self.properties))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = async_set()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 29)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        obj.properties = loxi.generic_util.unpack_list(reader, ofp.async_config_prop.async_config_prop.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.properties != other.properties: return False
        return True

    def pretty_print(self, q):
        q.text("async_set {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("properties = ");
                q.pp(self.properties)
            q.breakable()
        q.text('}')

message.subtypes[28] = async_set
'''
#-----meter mod message----------------------------------------------------

class meter_mod(message):
    subtypes = {}

    version = 4
    type = 30

    def __init__(self, xid=None, command=None, slotID=None,  meter_id=None, rate=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if command != None:
            self.command = command
        else:
            self.command = 0
        if slotID != None:
            self.slotID = slotID
        else:
            self.slotID = 0
        if meter_id != None:
            self.meter_id = meter_id
        else:
            self.meter_id = 0
        if rate != None:
            self.rate = rate
        else:
            self.rate = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!B", self.command))
        packed.append('/x00' * 1)
        packed.append(struct.pack("!H", self.slotID))
        packed.append(struct.pack("!L", self.meter_id))
        packed.append(struct.pack("!L", self.rate))
        packed.append('/x00' * 4)
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        subtype, = reader.peek('!H', 8)
        subclass = group_mod.subtypes.get(subtype)
        if subclass:
            return subclass.unpack(reader)

        obj = meter_mod()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 30)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        obj.command = reader.read("!B")[0]
        reader.skip(1)
        obj.slotID = reader.read("!H")[0]
        obj.meter_id = reader.read("!L")[0]
        obj.rate = reader.read("!L")[0]
        reader.skip(4)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.command != other.command: return False
        if self.slotID != other.slotID: return False
        if self.rate != other.rate: return False
        if self.meter_id != other.meter_id: return False
        return True

    def pretty_print(self, q):
        q.text("meter_mod {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("command = ");
                q.text("%#x" % self.command)
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(","); q.breakable()
                q.text("rate = ");
                q.text("%#x" % self.rate)
                q.text(","); q.breakable()
                q.text("meter_id = ");
                q.text("%#x" % self.meter_id)
            q.breakable()
        q.text('}')

message.subtypes[30] = meter_mod

class meter_add(message):
    version = 4
    type = 30
    command = 0

    def __init__(self, xid=None, slotID=None, meter_id=None, rate=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if slotID != None:
            self.slotID = slotID
        else:
            self.slotID = 0
        if meter_id != None:
            self.meter_id = meter_id
        else:
            self.meter_id = 0
        if rate != None:
            self.rate = rate
        else:
            self.rate = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0))  # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!B", self.command))
        packed.append('/x00' * 1)
        packed.append(struct.pack("!H", self.slotID))
        packed.append(struct.pack("!L", self.meter_id))
        packed.append(struct.pack("!L", self.rate))
        packed.append('/x00' * 4)
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = meter_add()
        _version = reader.read("!B")[0]
        assert (_version == 4)
        _type = reader.read("!B")[0]
        assert (_type == 30)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        _command = reader.read("!B")[0]
        assert(_command == 0)
        reader.skip(1)
        obj.slotID = reader.read("!H")[0]
        obj.meter_id = reader.read("!L")[0]
        obj.rate = reader.read("!L")[0]
        reader.skip(4)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.slotID != other.slotID: return False
        if self.meter_id != other.meter_id: return False
        if self.rate != other.rate: return False
        return True

    def pretty_print(self, q):
        q.text("meter_add {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(",");q.breakable()
                q.text("rate = ");
                q.text("%#x" % self.rate)
                q.text(",");q.breakable()
                q.text("meter_id = ");
                q.text("%#x" % self.meter_id)
            q.breakable()
        q.text('}')

meter_mod.subtypes[0] = meter_add

class meter_modify(message):
    version = 4
    type = 30
    command = 1

    def __init__(self, xid=None, slotID=None, meter_id=None, rate=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if slotID != None:
            self.slotID = slotID
        else:
            self.slotID = 0
        if meter_id != None:
            self.meter_id = meter_id
        else:
            self.meter_id = 0
        if rate != None:
            self.rate = rate
        else:
            self.rate = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0))  # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!B", self.command))
        packed.append('/x00' * 1)
        packed.append(struct.pack("!H", self.slotID))
        packed.append(struct.pack("!L", self.meter_id))
        packed.append(struct.pack("!L", self.rate))
        packed.append('/x00' * 4)
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = meter_modify()
        _version = reader.read("!B")[0]
        assert (_version == 4)
        _type = reader.read("!B")[0]
        assert (_type == 30)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        _command = reader.read("!B")[0]
        assert(_command == 1)
        reader.skip(1)
        obj.slotID = reader.read("!H")[0]
        obj.meter_id = reader.read("!L")[0]
        obj.rate = reader.read("!L")[0]
        reader.skip(4)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.slotID != other.slotID: return False
        if self.meter_id != other.meter_id: return False
        if self.rate != other.rate: return False
        return True

    def pretty_print(self, q):
        q.text("meter_modify {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(",");q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(",");q.breakable()
                q.text("meter_id = ");
                q.text("%#x" % self.meter_id)
                q.text(",");q.breakable()
                q.text("rate = ");
                q.text("%#x" % self.rate)
            q.breakable()
        q.text('}')

meter_mod.subtypes[1] = meter_modify


class meter_delete(message):
    version = 4
    type = 30
    command = 2

    def __init__(self, xid=None, slotID=None, meter_id=None, rate=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if slotID != None:
            self.slotID = slotID
        else:
            self.slotID = 0
        if rate != None:
            self.rate = rate
        else:
            self.rate = 0
        if meter_id != None:
            self.meter_id = meter_id
        else:
            self.meter_id = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0))  # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!B", self.command))
        packed.append('/x00' * 1)
        packed.append(struct.pack("!H", self.slotID))
        packed.append(struct.pack("!L", self.meter_id))
        packed.append(struct.pack("!L", self.rate))
        packed.append('/x00' * 4)
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = meter_delete()
        _version = reader.read("!B")[0]
        assert (_version == 4)
        _type = reader.read("!B")[0]
        assert (_type == 30)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        _command = reader.read("!B")[0]
        assert(_command == 2)
        reader.skip(1)
        obj.slotID = reader.read("!H")[0]
        obj.meter_id = reader.read("!L")[0]
        obj.rate = reader.read("!L")[0]
        reader.skip(4)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.slotID != other.slotID: return False
        if self.meter_id != other.meter_id: return False
        if self.rate != other.rate: return False
        return True

    def pretty_print(self, q):
        q.text("meter_delete {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(",");
                q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(",");
                q.breakable()
                q.text("rate = ");
                q.text("%#x" % self.rate)
                q.text(",");
                q.breakable()
                q.text("meter_id = ");
                q.text("%#x" % self.meter_id)
            q.breakable()
        q.text('}')

meter_mod.subtypes[2] = meter_delete

#-----counter mod message--------------------------------------------------

class counter_mod(message):
    subtypes = {}

    version = 4
    type = 31

    def __init__(self, xid=None, command=None, slotID=None, counter_id=None, value=None, byte_value=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if command != None:
            self.command = command
        else:
            self.command = 0
        if slotID != None:
            self.slotID = slotID
        else:
            self.slotID = 0
        if counter_id != None:
            self.counter_id = counter_id
        else:
            self.counter_id = 0
        if value != None:
            self.value = value
        else:
            self.value = 0
        if byte_value != None:
            self.byte_value = byte_value
        else:
            self.byte_value = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!B", self.command))
        packed.append('/x00' * 1)
        packed.append(struct.pack("!H", self.slotID))
        packed.append(struct.pack("!L", self.counter_id))
        packed.append(struct.pack("!Q", self.value))
        packed.append(struct.pack("!Q", self.byte_value))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        subtype, = reader.peek('!H', 8)
        subclass = group_mod.subtypes.get(subtype)
        if subclass:
            return subclass.unpack(reader)

        obj = counter_mod()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 31)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        obj.command = reader.read("!B")[0]
        reader.skip(1)
        obj.slotID = reader.read("!H")[0]
        obj.counter_id = reader.read("!L")[0]
        obj.value = reader.read("!L")[0]
        obj.byte_value = reader.read("!Q")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.command != other.command: return False
        if self.slotID != other.slotID: return False
        if self.counter_id != other.counter_id: return False
        if self.value != other.value: return False
        if self.byte_value != other.byte_value: return False
        return True

    def pretty_print(self, q):
        q.text("counter_mod {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(","); q.breakable()
                q.text("command = ");
                q.text("%#x" % self.command)
                q.text(","); q.breakable()
                q.text("counter_id = ");
                q.text("%#x" % self.counter_id)
                q.text(","); q.breakable()
                q.text("value = ");
                q.text("%#x" % self.value)
                q.text(","); q.breakable()
                q.text("byte_value = ");
                q.text("%#x" % self.byte_value)
            q.breakable()
        q.text('}')

message.subtypes[31] = counter_mod

class counter_add(message):
    version = 4
    type = 31
    command = 0
    def __init__(self, xid=None, slotID=None, counter_id=None, value=None, byte_value=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if slotID != None:
            self.slotID = slotID
        else:
            self.slotID = 0
        if counter_id != None:
            self.counter_id = counter_id
        else:
            self.counter_id = 0
        if value != None:
            self.value = value
        else:
            self.value = 0
        if byte_value != None:
            self.byte_value = byte_value
        else:
            self.byte_value = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!B", self.command))
        packed.append('/x00' * 1)
        packed.append(struct.pack("!H", self.slotID))
        packed.append(struct.pack("!L", self.counter_id))
        packed.append(struct.pack("!Q", self.value))
        packed.append(struct.pack("!Q", self.byte_value))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = counter_add()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 31)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        _command = reader.read("!B")[0]
        assert(_command == 0)
        reader.skip(1)
        obj.slotID = reader.read("!H")[0]
        obj.counter_id = reader.read("!L")[0]
        obj.value = reader.read("!L")[0]
        obj.byte_value = reader.read("!Q")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.slotID != other.slotID: return False
        if self.counter_id != other.counter_id: return False
        if self.value != other.value: return False
        if self.byte_value != other.byte_value: return False
        return True

    def pretty_print(self, q):
        q.text("counter_add {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(","); q.breakable()
                q.text("counter_id = ");
                q.text("%#x" % self.counter_id)
                q.text(","); q.breakable()
                q.text("value = ");
                q.text("%#x" % self.value)
                q.text(","); q.breakable()
                q.text("byte_value = ");
                q.text("%#x" % self.byte_value)
            q.breakable()
        q.text('}')

counter_mod.subtypes[0] = counter_add

class counter_delete(message):
    version = 4
    type = 31
    command = 1
    def __init__(self, xid=None, slotID=None, counter_id=None, value=None, byte_value=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if slotID != None:
            self.slotID = slotID
        else:
            self.slotID = 0
        if counter_id != None:
            self.counter_id = counter_id
        else:
            self.counter_id = 0
        if value != None:
            self.value = value
        else:
            self.value = 0
        if byte_value != None:
            self.byte_value = byte_value
        else:
            self.byte_value = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!B", self.command))
        packed.append('/x00' * 1)
        packed.append(struct.pack("!H", self.slotID))
        packed.append(struct.pack("!L", self.counter_id))
        packed.append(struct.pack("!Q", self.value))
        packed.append(struct.pack("!Q", self.byte_value))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = counter_delete()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 31)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        _command = reader.read("!B")[0]
        assert(_command == 1)
        reader.skip(3)
        obj.slotID = reader.read("!L")[0]
        obj.counter_id = reader.read("!L")[0]
        obj.value = reader.read("!L")[0]
        obj.byte_value = reader.read("!Q")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.slotID != other.slotID: return False
        if self.counter_id != other.counter_id: return False
        if self.value != other.value: return False
        if self.byte_value != other.byte_value: return False
        return True

    def pretty_print(self, q):
        q.text("counter_delete {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(","); q.breakable()
                q.text("counter_id = ");
                q.text("%#x" % self.counter_id)
                q.text(","); q.breakable()
                q.text("value = ");
                q.text("%#x" % self.value)
                q.text(","); q.breakable()
                q.text("byte_value = ");
                q.text("%#x" % self.byte_value)
            q.breakable()
        q.text('}')

counter_mod.subtypes[1] = counter_delete

class counter_clear(message):
    version = 4
    type = 31
    command = 2
    def __init__(self, xid=None, slotID=None, counter_id=None, value=None, byte_value=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if slotID != None:
            self.slotID = slotID
        else:
            self.slotID = 0
        if counter_id != None:
            self.counter_id = counter_id
        else:
            self.counter_id = 0
        if value != None:
            self.value = value
        else:
            self.value = 0
        if byte_value != None:
            self.byte_value = byte_value
        else:
            self.byte_value = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!B", self.command))
        packed.append('/x00' * 1)
        packed.append(struct.pack("!H", self.slotID))
        packed.append(struct.pack("!L", self.counter_id))
        packed.append(struct.pack("!Q", self.value))
        packed.append(struct.pack("!Q", self.byte_value))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = counter_clear()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 31)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        _command = reader.read("!B")[0]
        assert(_command == 2)
        reader.skip(1)
        obj.slotID = reader.read("!H")[0]
        obj.counter_id = reader.read("!L")[0]
        obj.value = reader.read("!L")[0]
        obj.byte_value = reader.read("!Q")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.slotID != other.slotID: return False
        if self.counter_id != other.counter_id: return False
        if self.value != other.value: return False
        if self.byte_value != other.byte_value: return False
        return True

    def pretty_print(self, q):
        q.text("counter_clear {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(","); q.breakable()
                q.text("counter_id = ");
                q.text("%#x" % self.counter_id)
                q.text(","); q.breakable()
                q.text("value = ");
                q.text("%#x" % self.value)
                q.text(","); q.breakable()
                q.text("byte_value = ");
                q.text("%#x" % self.byte_value)
            q.breakable()
        q.text('}')

counter_mod.subtypes[2] = counter_clear

#-----counter request message----------------------------------------------

class counter_request(message):
    version = 4
    type = 32

    def __init__(self, xid=None, command=None, slotID=None, counter_id=None, value=None, byte_value=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if command != None:
            self.command = command
        else:
            self.command = 0
        if slotID != None:
            self.slotID = slotID
        else:
            self.slotID = 0
        if counter_id != None:
            self.counter_id = counter_id
        else:
            self.counter_id = 0
        if value != None:
            self.value = value
        else:
            self.value = 0
        if byte_value != None:
            self.byte_value = byte_value
        else:
            self.byte_value = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!B", self.command))
        packed.append('/x00' * 1)
        packed.append(struct.pack("!H", self.slotID))
        packed.append(struct.pack("!L", self.counter_id))
        packed.append(struct.pack("!Q", self.value))
        packed.append(struct.pack("!Q", self.byte_value))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = counter_request()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 32)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        obj.command = reader.read("!B")[0]
        reader.skip(1)
        obj.slotID = reader.read("!H")[0]
        obj.counter_id = reader.read("!L")[0]
        obj.value = reader.read("!L")[0]
        obj.byte_value = reader.read("!Q")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.command != other.command: return False
        if self.slotID != other.slotID: return False
        if self.counter_id != other.counter_id: return False
        if self.value != other.value: return False
        if self.byte_value != other.byte_value: return False
        return True

    def pretty_print(self, q):
        q.text("counter_request {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("command = ");
                q.text("%#x" % self.command)
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(","); q.breakable()
                q.text("counter_id = ");
                q.text("%#x" % self.counter_id)
                q.text(","); q.breakable()
                q.text("value = ");
                q.text("%#x" % self.value)
                q.text(","); q.breakable()
                q.text("byte_value = ");
                q.text("%#x" % self.byte_value)
            q.breakable()
        q.text('}')

message.subtypes[32] = counter_request

#-----counter reply message------------------------------------------------

class counter_reply(message):
    version = 4
    type = 33

    def __init__(self, xid=None, command=None, slotID=None, counter_id=None, value=None, byte_value=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if command != None:
            self.command = command
        else:
            self.command = 0
        if slotID != None:
            self.slotID = slotID
        else:
            self.slotID = 0
        if counter_id != None:
            self.counter_id = counter_id
        else:
            self.counter_id = 0
        if value != None:
            self.value = value
        else:
            self.value = 0
        if byte_value != None:
            self.byte_value = byte_value
        else:
            self.byte_value = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!B", self.command))
        packed.append('/x00' * 1)
        packed.append(struct.pack("!H", self.slotID))
        packed.append(struct.pack("!L", self.counter_id))
        packed.append(struct.pack("!Q", self.value))
        packed.append(struct.pack("!Q", self.byte_value))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = counter_reply()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 33)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        obj.command = reader.read("!B")[0]
        reader.skip(1)
        obj.slotID = reader.read("!H")[0]
        obj.counter_id = reader.read("!L")[0]
        obj.value = reader.read("!L")[0]
        obj.byte_value = reader.read("!Q")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.command != other.command: return False
        if self.counter_id != other.counter_id: return False
        if self.slotID != other.slotID: return False
        if self.value != other.value: return False
        if self.byte_value != other.byte_value: return False
        return True

    def pretty_print(self, q):
        q.text("counter_reply {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("command = ");
                q.text("%#x" % self.command)
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(","); q.breakable()
                q.text("counter_id = ");
                q.text("%#x" % self.counter_id)
                q.text(","); q.breakable()
                q.text("value = ");
                q.text("%#x" % self.value)
                q.text(","); q.breakable()
                q.text("byte_value = ");
                q.text("%#x" % self.byte_value)
            q.breakable()
        q.text('}')

message.subtypes[33] = counter_reply

#-----queryall request message---------------------------------------------

class queryall_request(message):
    version = 4
    type = 34

    def __init__(self, xid=None, slotID=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if slotID != None:
            self.slotID = slotID
        else:
            self.slotID = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!H", self.slotID))
        packed.append('/x00' * 6)
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = queryall_request()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 34)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        obj.slotID = reader.read("!H")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.slotID != other.slotID: return False
        return True

    def pretty_print(self, q):
        q.text("queryall_request {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
            q.breakable()
        q.text('}')

message.subtypes[34] = queryall_request

#-----queryall fin message-------------------------------------------------

class queryall_fin(message):
    version = 4
    type = 35

    def __init__(self, xid=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = queryall_fin()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 35)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        return True

    def pretty_print(self, q):
        q.text("queryall_fin {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
            q.breakable()
        q.text('}')

message.subtypes[35] = queryall_fin

#-----instruction block mod message----------------------------------------

class instruction_block_mod(message):
    version = 4
    type = 36

    def __init__(self, xid=None, command=None, instruction_num=None, related_table_id=None, slotID=None, instruction_block_id=None, ):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if command != None:
            self.command = command
        else:
            self.command = 0
        if instruction_num != None:
            self.instruction_num = instruction_num
        else:
            self.instruction_num = 0
        if related_table_id != None:
            self.related_table_id = related_table_id
        else:
            self.related_table_id = 0
        if slotID != None:
            self.slotID = slotID
        else:
            self.slotID = 0
        if instruction_block_id != None:
            self.instruction_block_id = instruction_block_id
        else:
            self.instruction_block_id = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!B", self.command))
        packed.append(struct.pack("!B", self.instruction_num))
        packed.append(struct.pack("!B", self.related_table_id))
        packed.append('/x00' * 1)
        packed.append(struct.pack("!H", self.slotID))
        packed.append(struct.pack("!H", self.instruction_block_id))
        #packed.append(struct.pack("!", self.))??pof_instruction
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = instruction_block_mod()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 36)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        obj.command = reader.read("!B")[0]
        obj.instruction_num = reader.read("!B")[0]
        obj.related_table_id = reader.read("!B")[0]
        reader.skip(1)
        obj.slotID = reader.read("!H")[0]
        obj.instruction_block_id = reader.read("!H")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.command != other.command: return False
        if self.instruction_num != other.instruction_num: return False
        if self.related_table_id != other.related_table_id: return False
        if self.slotID != other.slotID: return False
        if self.instruction_block_id != other.instruction_block_id: return False
        return True

    def pretty_print(self, q):
        q.text("instruction_block_mod {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("command = ");
                q.text("%#x" % self.command)
                q.text(","); q.breakable()
                q.text("instruction_num = ");
                q.text("%#x" % self.instruction_num)
                q.text(","); q.breakable()
                q.text("related_table_id = ");
                q.text("%#x" % self.related_table_id)
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(","); q.breakable()
                q.text("instruction_block_id = ");
                q.text("%#x" % self.instruction_block_id)
            q.breakable()
        q.text('}')

message.subtypes[36] = instruction_block_mod

#-----slot config message--------------------------------------------------

class slot_config(message):
    version = 4
    type = 101

    def __init__(self, xid=None, slotID=None, flag=None, rsv=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if slotID != None:
            self.slotID = slotID
        else:
            self.slotID = 0
        if flag != None:
            self.flag = flag
        else:
            self.flag = 0
        if rsv != None:
            self.rsv = rsv
        else:
            self.rsv = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!H", self.slotID))
        packed.append(struct.pack("!B", self.flag))
        packed.append(struct.pack("!5B",self.rsv))#??
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = slot_config()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 101)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        obj.slotID = reader.read("!H")[0]
        obj.flag = reader.read("!B")[0]
        obj.rsv = reader.read("!5B")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.slotID != other.slotID: return False
        if self.flag != other.flag: return False
        if self.rsv != other.rsv: return False
        return True

    def pretty_print(self, q):
        q.text("slot_config {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(","); q.breakable()
                q.text("flag = ");
                q.text("%#x" % self.flag)
                q.text(","); q.breakable()
                q.text("rsv = ");
                q.text("%#x" % self.rsv)
            q.breakable()
        q.text('}')

message.subtypes[101] = slot_config

#-----slot status message--------------------------------------------------

class slot_status(message):
    version = 4
    type = 102

    def __init__(self, xid=None, slotID=None, slot_status=None, resend_flag=None, rsv=None):
        if xid != None:
            self.xid = xid
        else:
            self.xid = None
        if slotID != None:
            self.slotID = slotID
        else:
            self.slotID = 0
        if slot_status != None:
            self.slot_status = slot_status
        else:
            self.slot_status = 0
        if resend_flag != None:
            self.resend_flag = resend_flag
        else:
            self.resend_flag = 0
        if rsv != None:
            self.rsv = rsv
        else:
            self.rsv = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!B", self.version))
        packed.append(struct.pack("!B", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for length at index 2
        packed.append(struct.pack("!L", self.xid))
        packed.append(struct.pack("!H", self.slotID))
        packed.append(struct.pack("!B", self.slot_status))
        packed.append(struct.pack("!B", self.resend_flag))
        packed.append(struct.pack("!4B",self.rsv))#??
        length = sum([len(x) for x in packed])
        packed[2] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = slot_status()
        _version = reader.read("!B")[0]
        assert(_version == 4)
        _type = reader.read("!B")[0]
        assert(_type == 102)
        _length = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_length, 4)
        obj.xid = reader.read("!L")[0]
        obj.slotID = reader.read("!H")[0]
        obj.slot_status = reader.read("!B")[0]
        obj.resend_flag = reader.read("!B")[0]
        obj.rsv = reader.read("!4B")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.xid != other.xid: return False
        if self.slotID != other.slotID: return False
        if self.slot_status != other.slot_status: return False
        if self.resend_flag != other.resend_flag: return False
        if self.rsv != other.rsv: return False
        return True

    def pretty_print(self, q):
        q.text("slot_status {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("xid = ");
                if self.xid != None:
                    q.text("%#x" % self.xid)
                else:
                    q.text('None')
                q.text(","); q.breakable()
                q.text("slotID = ");
                q.text("%#x" % self.slotID)
                q.text(",");
                q.breakable()
                q.text("slot_status = ");
                q.text("%#x" % self.slot_status)
                q.text(","); q.breakable()
                q.text("resend_flag = ");
                q.text("%#x" % self.resend_flag)
                q.text(","); q.breakable()
                q.text("rsv = ");
                q.text("%#x" % self.rsv)
            q.breakable()
        q.text('}')

message.subtypes[102] = slot_status


def parse_header(buf):
    if len(buf) < 8:
        raise loxi.ProtocolError("too short to be an OpenFlow message")
    return struct.unpack_from("!BBHL", buf)

def parse_message(buf):
    msg_ver, msg_type, msg_len, msg_xid = parse_header(buf)
    if msg_ver != ofp.POF_VERSION and msg_type != ofp.POFT_HELLO:
        raise loxi.ProtocolError("wrong OpenFlow version (expected %d, got %d)" % (ofp.POF_VERSION, msg_ver))
    if len(buf) != msg_len:
        raise loxi.ProtocolError("incorrect message size")
    return message.unpack(loxi.generic_util.OFReader(buf))
