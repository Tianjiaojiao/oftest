# Copyright (c) 2008 The Board of Trustees of The Leland Stanford Junior University
# Copyright (c) 2011, 2012 Open Networking Foundation
# Copyright (c) 2012, 2013 Big Switch Networks, Inc.
# See the file LICENSE.pyloxi which should have been included in the source distribution

# Automatically generated by LOXI from template module.py
# Do not modify

import struct
import loxi
import util
import loxi.generic_util

import sys
ofp = sys.modules['loxi.pof']

class action(loxi.OFObject):
    subtypes = {}

    def __init__(self, type=None):
        if type != None:
            self.type = type
        else:
            self.type = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for len at index 1
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        subtype, = reader.peek('!H', 0)
        subclass = action.subtypes.get(subtype)
        if subclass:
            return subclass.unpack(reader)

        obj = action()
        obj.type = reader.read("!H")[0]
        _len = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_len, 4)
        reader.skip(4)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.type != other.type: return False
        return True

    def pretty_print(self, q):
        q.text("action {")
        with q.group():
            with q.indent(2):
                q.breakable()
            q.breakable()
        q.text('}')

class output(action):
    type = 0

    def __init__(self, portId_type=None, metadata_offset=None, metadata_len=None, packet_offset=None, value=None, field=None):
        if portId_type != None:
            self.portId_type = portId_type
        else:
            self.portId_type = 0
        if metadata_offset != None:
            self.metadata_offset = metadata_offset
        else:
            self.metadata_offset = 0
        if metadata_len != None:
            self.metadata_len =metadata_len
        else:
            self.metadata_len = 0
        if packet_offset != None:
            self.packet_offset = packet_offset
        else:
            self.packet_offset = 0
        if value != None:
            self.value = value
        else:
            self.value = 0
        if field != None:
            self.field = field
        else:
            self.field = ofp.match
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for len at index 1
        packed.append(struct.pack("!B", self.portId_type))
        packed.append('\x00' * 1)
        packed.append(struct.pack("!H", self.metadata_offset))
        packed.append(struct.pack("!H", self.metadata_len))
        packed.append(struct.pack("!H", self.packet_offset))
        if self.portId_type == 0:
            packed.append(struct.pack("!L", self.value))
            packed.append('\x00' * 4)
        else:
            packed.append(self.field.pack())
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = output()
        _type = reader.read("!H")[0]
        assert(_type == 0)
        _len = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_len, 4)
        obj.portId_type = reader.read("!B")[0]#util.unpack_port_no(reader)
        reader.skip(1)
        obj.metadata_offset = reader.read("!H")[0]
        obj.metadata_len = reader.read("!H")[0]
        obj.packet_offset = reader.read("!H")[0]
        if obj.portID_type == 0:
            obj.value = reader.read("!L")[0]
            reader.skip(4)
        else:
            obj.field = pof_match.unpack(reader)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.output_port_id != other.output_port_id: return False
        if self.metadata_offset != other.metadata_offset: return False
        if self.metadata_len != other.metadata_len: return False
        if self.packet_offset != other.packet_offset: return False
        return True

    def pretty_print(self, q):
        q.text("output {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("output_port_id = ");
                q.text("%#x" % self.output_port_id)#util.pretty_port(self.port))
                q.text(","); q.breakable()
                q.text("metadata_offset = ");
                q.text("%#x" % self.metadata_offset)
                q.text(","); q.breakable()
                q.text("metadata_len = ");
                q.text("%#x" % self.metadata_len)
                q.text(","); q.breakable()
                q.text("packet_offset = ");
                q.text("%#x" % self.packet_offset)
            q.breakable()
        q.text('}')

action.subtypes[0] = output

class set_field(action):
    type = 1

    def __init__(self, field_setting=None):
        if field_setting != None:
            self.field_setting = field_setting
        else:
            self.field_setting = ofp.match_x
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for len at index 1
        packed.append(self.field_setting.pack())
        length = sum([len(x) for x in packed])
        packed.append(loxi.generic_util.pad_to(8, length))#??
        length += len(packed[-1])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = set_field()
        _type = reader.read("!H")[0]
        assert(_type == 1)
        _len = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_len, 4)
        obj.field_setting = ofp.match_x.unpack(reader)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.field_setting != other.field_setting: return False
        return True

    def pretty_print(self, q):
        q.text("set_field {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("field_setting = ");
                q.pp(self.field_setting)
            q.breakable()
        q.text('}')

action.subtypes[1] = set_field

class set_field_from_metadata(action):
    type = 2

    def __init__(self, field_setting=None, metadata_offset=None):
        if field_setting != None:
            self.field_setting = field_setting
        else:
            self.field_setting = None
        if metadata_offset != None:
            self.metadata_offset = metadata_offset
        else:
            self.metadata_offset = None
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for len at index 1
        packed.append(self.field_setting.pack())
        packed.append(struct.pack("!H", self.metadata_offset))
        length = sum([len(x) for x in packed])
        packed.append(loxi.generic_util.pad_to(8, length))
        length += len(packed[-1])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = set_field_from_metadata()
        _type = reader.read("!H")[0]
        assert(_type == 2)
        _len = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_len, 4)
        obj.field_setting = ofp.oxm.oxm.unpack(reader)
        obj.metadata_offset = reader.read("!H")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.field_setting != other.field_setting: return False
        if self.metadata_offset != other.metadata: return False
        return True

    def pretty_print(self, q):
        q.text("set_field {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("field_setting = ");
                q.pp(self.field_setting)
                q.text(",");
                q.breakable()
                q.text("metadata_offset = ");
                q.text("%#x" % self.metadata_offset)
            q.breakable()
        q.text('}')

action.subtypes[2] = set_field_from_metadata

class modify_field(action):
    type = 3

    def __init__(self, field=None, increment=None):
        if field != None:
            self.field = field
        else:
            self.field = ofp.match()
        if increment != None:
            self.increment = increment
        else:
            self.increment = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for len at index 1
        packed.append(self.field.pack())
        packed.append(struct.pack("!i", self.increment))
        length = sum([len(x) for x in packed])
        packed.append(loxi.generic_util.pad_to(8, length))
        length += len(packed[-1])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = modify_field()
        _type = reader.read("!H")[0]
        assert(_type == 3)
        _len = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_len, 4)
        obj.field = ofp.match.unpack(reader)
        obj.increment = reader.read("!i")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.field != other.field: return False
        if self.increment != other.increment: return False
        return True

    def pretty_print(self, q):
        q.text("modify_field {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("field = ");
                q.pp(self.field)
                q.text(",");
                q.breakable()
                q.text("increment = ");
                q.text("%#x" % self.increment)
            q.breakable()
        q.text('}')

action.subtypes[3] = modify_field

class add_field(action):
    type = 4

    def __init__(self, tag_id=None, tag_pos=None, tag_len=None, tag_value=None):
        if tag_id != None:
            self.tag_id = tag_id
        else:
            self.tag_id = 0
        if tag_pos != None:
            self.tag_pos = tag_pos
        else:
            self.tag_pos = 0
        if tag_len != None:
            self.tag_len = tag_len
        else:
            self.tag_len = 0
        if tag_value != None:
            self.tag_value = tag_value
        else:
            self.tag_value = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for len at index 1
        packed.append(struct.pack("!H", self.tag_id))
        packed.append(struct.pack("!H", self.tag_pos))
        packed.append(struct.pack("!L", self.tag_len))
        packed.append(struct.pack("!Q", self.tag_value))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = add_field()
        _type = reader.read("!H")[0]
        assert(_type == 4)
        _len = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_len, 4)
        obj.tag_id = reader.read("!H")[0]
        obj.tag_pos = reader.read("!H")[0]
        obj.tag_len = reader.read("!L")[0]
        obj.tag_value = reader.read("!Q")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.tag_id != other.tag_id: return False
        if self.tag_pos != other.tag_pos: return False
        if self.tag_len != other.tag_len: return False
        if self.tag_value != other.tag_value: return False
        return True

    def pretty_print(self, q):
        q.text("add_field {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("tag_id = ");
                q.text("%#x" % self.tag_id)
                q.text(",");
                q.breakable()
                q.text("tag_pos = ");
                q.text("%#x" % self.tag_pos)
                q.text(",");
                q.breakable()
                q.text("tag_len = ");
                q.text("%#x" % self.tag_len)
                q.text(",");
                q.breakable()
                q.text("tag_value = ");
                q.text("%#x" % self.tag_value)
            q.breakable()
        q.text('}')

action.subtypes[4] = add_field

class delete_field(action):
    type = 5

    def __init__(self, tag_pos=None, tag_len=None):
        if tag_pos != None:
            self.tag_pos = tag_pos
        else:
            self.tag_pos = 0
        if tag_len != None:
            self.tag_len = tag_len
        else:
            self.tag_len = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for len at index 1
        packed.append(struct.pack("!H", self.tag_pos))
        packed.append(struct.pack("!L", self.tag_len))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = delete_field()
        _type = reader.read("!H")[0]
        assert(_type == 5)
        _len = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_len, 4)
        obj.tag_pos = reader.read("!H")[0]
        obj.tag_len = reader.read("!L")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.tag_pos != other.tag_pos: return False
        if self.tag_len != other.tag_len: return False
        return True

    def pretty_print(self, q):
        q.text("delete_field {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("tag_pos = ");
                q.text("%#x" % self.tag_pos)
                q.text(",");
                q.breakable()
                q.text("tag_len = ");
                q.text("%#x" % self.tag_len)
            q.breakable()
        q.text('}')

action.subtypes[5] = delete_field

class calculate_checksum(action):
    type = 6

    def __init__(self, checksum_pos=None, checksum_len=None, cal_startpos=None, cal_len=None):
        if checksum_pos != None:
            self.checksum_pos = checksum_pos
        else:
            self.checksum_pos = None
        if checksum_len != None:
            self.checksum_len = checksum_len
        else:
            self.checksum_len = None
        if cal_startpos != None:
            self.cal_startpos = cal_startpos
        else:
            self.cal_startpos = None
        if cal_len != None:
            self.cal_len = cal_len
        else:
            self.cal_len = None
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for len at index 1
        packed.append(struct.pack("!H", self.checksum_pos))
        packed.append(struct.pack("!H", self.checksum_len))
        packed.append(struct.pack("!H", self.cal_startpos))
        packed.append(struct.pack("!H", self.cal_len))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = calculate_checksum()
        _type = reader.read("!H")[0]
        assert(_type == 6)
        _len = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_len, 4)
        obj.checksum_pos = reader.read("!H")[0]
        obj.checksum_len = reader.read("!H")[0]
        obj.cal_startpos = reader.read("!H")[0]
        obj.cal_len = reader.read("!H")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.checksum_pos != other.checksum_pos: return False
        if self.checksum_len != other.checksum_len: return False
        if self.cal_startpos != other.cal_startpos: return False
        if self.cal_len != other.cal_len: return False
        return True

    def pretty_print(self, q):
        q.text("calculate_checksum {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("checksum_pos = ");
                q.text("%#x" % self.checksum_pos)
                q.text(",");
                q.breakable()
                q.text("checksum_len = ");
                q.text("%#x" % self.checksum_len)
                q.text(",");
                q.breakable()
                q.text("cal_startpos = ");
                q.text("%#x" % self.cal_startpos)
                q.text(",");
                q.breakable()
                q.text("cal_len = ");
                q.text("%#x" % self.cal_len)
            q.breakable()
        q.text('}')

action.subtypes[6] = calculate_checksum

class group(action):
    type = 7

    def __init__(self, group_id=None):
        if group_id != None:
            self.group_id = group_id
        else:
            self.group_id = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for len at index 1
        packed.append(struct.pack("!L", self.group_id))
        packed.append('\x00' * 4)
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = group()
        _type = reader.read("!H")[0]
        assert(_type == 7)
        _len = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_len, 4)
        obj.group_id = reader.read("!L")[0]
        reader.skip(4)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.group_id != other.group_id: return False
        return True

    def pretty_print(self, q):
        q.text("group {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("group_id = ");
                q.text("%#x" % self.group_id)
            q.breakable()
        q.text('}')

action.subtypes[7] = group

class drop(action):
    type = 8

    def __init__(self, reason_code=None):
        if reason_code != None:
            self.reason_code = reason_code
        else:
            self.reason_code = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for len at index 1
        packed.append(struct.pack("!L", self.reason_code))
        packed.append('\x00' * 4)
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = drop()
        _type = reader.read("!H")[0]
        assert(_type == 8)
        _len = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_len, 4)
        obj.reason_code = reader.read("!L")[0]
        reader.skip(4)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.reason_code != other.reason_code: return False
        return True

    def pretty_print(self, q):
        q.text("drop {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("reason_code = ");
                q.text("%#x" % self.reason_code)
            q.breakable()
        q.text('}')

action.subtypes[8] = drop

class packet_in(action):
    type = 9

    def __init__(self, reason_code=None):
        if reason_code != None:
            self.reason_code = reason_code
        else:
            self.reason_code = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for len at index 1
        packed.append(struct.pack("!L", self.reason_code))
        packed.append('\x00' * 4)
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = packet_in()
        _type = reader.read("!H")[0]
        assert(_type == 9)
        _len = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_len, 4)
        obj.reason_code = reader.read("!L")[0]
        reader.skip(4)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.reason_code != other.reason_code: return False
        return True

    def pretty_print(self, q):
        q.text("packet_in {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("reason_code = ");
                q.text("%#x" % self.reason_code)
            q.breakable()
        q.text('}')

action.subtypes[9] = packet_in

class counter(action):
    type = 10

    def __init__(self, counter_id=None):
        if counter_id != None:
            self.counter_id = counter_id
        else:
            self.counter_id = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for len at index 1
        packed.append(struct.pack("!L", self.counter_id))
        packed.append('\x00' * 4)
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = counter()
        _type = reader.read("!H")[0]
        assert(_type == 10)
        _len = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_len, 4)
        obj.counter_id = reader.read("!L")[0]
        reader.skip(4)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.counter_id != other.counter_id: return False
        return True

    def pretty_print(self, q):
        q.text("counter {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("counter_id = ");
                q.text("%#x" % self.counter_id)
            q.breakable()
        q.text('}')

action.subtypes[10] = counter

#-----pofswitch do not support, which is shown at common/pof_byte_transfer.c +568---
"""
class experimenter(action):
    subtypes = {}

    type = 65535

    def __init__(self, experimenter=None, data=None):
        if experimenter != None:
            self.experimenter = experimenter
        else:
            self.experimenter = 0
        if data != None:
            self.data = data
        else:
            self.data = ''
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for len at index 1
        packed.append(struct.pack("!L", self.experimenter))
        packed.append(self.data)
        length = sum([len(x) for x in packed])
        packed.append(loxi.generic_util.pad_to(8, length))
        length += len(packed[-1])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        subtype, = reader.peek('!L', 4)
        subclass = experimenter.subtypes.get(subtype)
        if subclass:
            return subclass.unpack(reader)

        obj = experimenter()
        _type = reader.read("!H")[0]
        assert(_type == 65535)
        _len = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_len, 4)
        obj.experimenter = reader.read("!L")[0]
        obj.data = str(reader.read_all())
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.experimenter != other.experimenter: return False
        if self.data != other.data: return False
        return True

    def pretty_print(self, q):
        q.text("experimenter {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("data = ");
                q.pp(self.data)
            q.breakable()
        q.text('}')

action.subtypes[65535] = experimenter
"""
















