# Copyright (c) 2008 The Board of Trustees of The Leland Stanford Junior University
# Copyright (c) 2011, 2012 Open Networking Foundation
# Copyright (c) 2012, 2013 Big Switch Networks, Inc.
# See the file LICENSE.pyloxi which should have been included in the source distribution

# Automatically generated by LOXI from template module.py
# Do not modify

import struct
import loxi
import util
import loxi.generic_util

import sys
ofp = sys.modules['loxi.pof']

class instruction(loxi.OFObject):
    subtypes = {}

    def __init__(self, type=None):
        if type != None:
            self.type = type
        else:
            self.type = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for len at index 1
        packed.append('/x00' * 4)
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        subtype, = reader.peek('!H', 0)
        subclass = instruction.subtypes.get(subtype)
        if subclass:
            return subclass.unpack(reader)

        obj = instruction()
        obj.type = reader.read("!H")[0]
        _len = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_len, 4)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.type != other.type: return False
        return True

    def pretty_print(self, q):
        q.text("instruction {")
        with q.group():
            with q.indent(2):
                q.breakable()
            q.breakable()
        q.text('}')

class goto_table(instruction):
    type = 1

    def __init__(self, next_table_id=None, match_field_num=None, packet_offest=None, match=None):
        if next_table_id != None:
            self.next_table_id = next_table_id
        else:
            self.next_table_id = 0
        if match_field_num != None:
            self.match_field_num = match_field_num
        else:
            self.match_field_num = 0
        if packet_offest != None:
            self.packet_offest = packet_offest
        else:
            self.packet_offest = 0
        if match != None:
            self.match = match
        else:
            self.match = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for len at index 1
        packed.append(struct.pack("!B", self.next_table_id))
        packed.append(struct.pack("!B", self.match_field_num))
        packed.append(struct.pack("!H", self.packet_offest))
        packed.append('\x00' * 4)
        packed.append(loxi.generic_util.pack_list(self.match))#??
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = goto_table()
        _type = reader.read("!H")[0]
        assert(_type == 1)
        _len = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_len, 4)
        obj.next_table_id = reader.read("!B")[0]
        obj.match_field_num = reader.read("!B")[0]
        obj.packet_offest = reader.read("!H")[0]
        reader.skip(4)
        obj.match = loxi.generic_util.unpack_list(reader, ofp.match.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.next_table_id != other.next_table_id: return False
        if self.match_field_num != other.match_field_num: return False
        if self.packet_offest != other.packet_offset: return False
        if self.match != other.match: return False
        return True

    def pretty_print(self, q):
        q.text("goto_table {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("next_table_id = ");
                q.text("%#x" % self.next_table_id)
                q.text(","); q.breakable()
                q.text("match_field_num = ");
                q.text("%#x" % self.match_field_num)
                q.text(","); q.breakable()
                q.text("packet_offset = ");
                q.text("%#x" % self.packet_offest)
                q.text(","); q.breakable()
                q.text("match = ");
                q.text("%#x" % self.match)
            q.breakable()
        q.text('}')

instruction.subtypes[1] = goto_table

class write_metadata(instruction):
    type = 2

    def __init__(self, metadata_offset=None, len=None, value=None):
        if metadata_offset != None:
            self.metadata_offset = metadata_offset
        else:
            self.metadata_offset = 0
        if len != None:
            self.len = len
        else:
            self.len = 0
        if value != None:
            self.value = value
        else:
            self.value = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for len at index 1
        packed.append(struct.pack("!H", self.metadata_offset))
        packed.append(struct.pack("!H", self.len))
        packed.append(struct.pack("!L", self.value))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = write_metadata()
        _type = reader.read("!H")[0]
        assert(_type == 2)
        _len = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_len, 4)
        obj.metadata_offset = reader.read("!H")[0]
        obj.len = reader.read("!H")[0]
        obj.value = reader.read("!L")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.metadata_offset != other.metadata_offset: return False
        if self.len != other.len: return False
        if self.value != other.value: return False
        return True

    def pretty_print(self, q):
        q.text("write_metadata {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("metadata_offset = ");
                q.text("%#x" % self.metadata_offset)
                q.text(","); q.breakable()
                q.text("len = ");
                q.text("%#x" % self.len)
                q.text(","); q.breakable()
                q.text("value = ");
                q.text("%#x" % self.value)
            q.breakable()
        q.text('}')

instruction.subtypes[2] = write_metadata

#-----pofswitch do not support, which is shown at common/pof_byte_transfer.c +606---
"""
class write_actions(instruction):
    type = 3

    def __init__(self, actions=None):
        if actions != None:
            self.actions = actions
        else:
            self.actions = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for len at index 1
        packed.append('\x00' * 4)
        packed.append(loxi.generic_util.pack_list(self.actions))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = write_actions()
        _type = reader.read("!H")[0]
        assert(_type == 3)
        _len = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_len, 4)
        reader.skip(4)
        obj.actions = loxi.generic_util.unpack_list(reader, ofp.action.action.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.actions != other.actions: return False
        return True

    def pretty_print(self, q):
        q.text("write_actions {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("actions = ");
                q.pp(self.actions)
            q.breakable()
        q.text('}')

instruction.subtypes[3] = write_actions
"""
class apply_actions(instruction):
    type = 4

    def __init__(self, action_num=None, actions=None):
        if action_num != None:
            self.action_num = action_num
        else:
            self.action_num = 0
        if actions != None:
            self.actions = actions
        else:
            self.actions = []
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for len at index 1
        packed.append(struct.pack("!B", self.action_num))
        packed.append('\x00' * 7)
        packed.append(loxi.generic_util.pack_list(self.actions))#??
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = apply_actions()
        _type = reader.read("!H")[0]
        assert(_type == 4)
        _len = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_len, 4)
        obj.action_num = reader.read("!B")[0]
        reader.skip(7)
        obj.actions = loxi.generic_util.unpack_list(reader, ofp.action.action.unpack)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.action_num != other.action_num: return False
        if self.actions != other.actions: return False
        return True

    def pretty_print(self, q):
        q.text("apply_actions {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("action_num = ");
                q.text("%#x" % self.action_num)
                q.text(","); q.breakable()
                q.text("actions = ");
                q.pp(self.actions)
            q.breakable()
        q.text('}')

instruction.subtypes[4] = apply_actions

#-----pofswitch do not support, which is shown at common/pof_byte_transfer.c +613---
"""
class clear_actions(instruction):
    type = 5

    def __init__(self):
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for len at index 1
        packed.append('\x00' * 4)
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = clear_actions()
        _type = reader.read("!H")[0]
        assert(_type == 5)
        _len = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_len, 4)
        reader.skip(4)
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        return True

    def pretty_print(self, q):
        q.text("clear_actions {")
        with q.group():
            with q.indent(2):
                q.breakable()
            q.breakable()
        q.text('}')

instruction.subtypes[5] = clear_actions
"""
class meter(instruction):
    type = 6

    def __init__(self, meter_id=None):
        if meter_id != None:
            self.meter_id = meter_id
        else:
            self.meter_id = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for len at index 1
        packed.append(struct.pack("!L", self.meter_id))
        packed.append('\x00' * 4)
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = meter()
        _type = reader.read("!H")[0]
        assert(_type == 6)
        _len = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_len, 4)
        obj.meter_id = reader.read("!L")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.meter_id != other.meter_id: return False
        return True

    def pretty_print(self, q):
        q.text("meter {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("meter_id = ");
                q.text("%#x" % self.meter_id)
            q.breakable()
        q.text('}')

instruction.subtypes[6] = meter

class write_metadata_from_packet(instruction):
    type = 7

    def __init__(self, metadata_offset=None, packet_offset=None, len=None):
        if metadata_offset != None:
            self.metadata_offset = metadata_offset
        else:
            self.metadata_offset = 0
        if packet_offset != None:
            self.packet_offset = packet_offset
        else:
            self.packet_offset = 0
        if len != None:
            self.len = len
        else:
            self.len = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for len at index 1
        packed.append(struct.pack("!H", self.metadata_offset))
        packed.append(struct.pack("!H", self.packet_offset))
        packed.append(struct.pack("!H", self.len))
        packed.append('\x00' * 2)
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = write_metadata_from_packet()
        _type = reader.read("!H")[0]
        assert(_type == 7)
        _len = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_len, 4)
        obj.metadata_offset = reader.read("!H")[0]
        obj.packet_offset = reader.read("!H")[0]
        obj.len = reader.read("!H")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.metadata_offset != other.metadata_offset: return False
        if self.packet_offset != other.packet_offset: return False
        if self.len != other.len: return False
        return True

    def pretty_print(self, q):
        q.text("write_metadata_from_packet {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("metadata_offset = ");
                q.text("%#x" % self.metadata_offset)
                q.text(","); q.breakable()
                q.text("packet_offset = ");
                q.text("%#x" % self.packet_offset)
                q.text(","); q.breakable()
                q.text("len = ");
                q.text("%#x" % self.len)
            q.breakable()
        q.text('}')

instruction.subtypes[7] = write_metadata_from_packet

class goto_direct_table(instruction):
    type = 8

    def __init__(self, next_table_id=None, packet_offset=None, table_entry_index=None):
        if next_table_id != None:
            self.next_table_id = next_table_id
        else:
            self.next_table_id = 0
        if packet_offset != None:
            self.packet_offset = packet_offset
        else:
            self.packet_offset = 0
        if table_entry_index != None:
            self.table_entry_index = table_entry_index
        else:
            self.table_entry_index = 0
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for len at index 1
        packed.append(struct.pack("!B", self.next_table_id))
        packed.append('\x00' * 1)
        packed.append(struct.pack("!H", self.packet_offset))
        packed.append(struct.pack("!L", self.table_entry_index))
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        obj = goto_direct_table()
        _type = reader.read("!H")[0]
        assert(_type == 8)
        _len = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_len, 4)
        obj.next_table_id = reader.read("!B")[0]
        reader.skip(1)
        obj.packet_offset = reader.read("!H")[0]
        obj.table_entry_index = reader.read("!L")[0]
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.next_table_id != other.next_table_id: return False
        if self.packet_offset != other.packet_offset: return False
        if self.table_entry_index != other.table_entry_index: return False
        return True

    def pretty_print(self, q):
        q.text("goto_direct_table {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("next_table_id = ");
                q.text("%#x" % self.table_id)
                q.text(",");
                q.breakable()
                q.text("packet_offset = ");
                q.text("%#x" % self.packet_offset)
                q.text(",");
                q.breakable()
                q.text("table_entry_index = ");
                q.text("%#x" % self.table_entry_index)
            q.breakable()
        q.text('}')

instruction.subtypes[8] = goto_direct_table

#-----pofswitch do not support, which is shown at common/pof_byte_transfer.c +620---
"""
class experimenter(instruction):
    subtypes = {}

    type = 65535

    def __init__(self, experimenter=None, data=None):
        if experimenter != None:
            self.experimenter = experimenter
        else:
            self.experimenter = 0
        if data != None:
            self.data = data
        else:
            self.data = ''
        return

    def pack(self):
        packed = []
        packed.append(struct.pack("!H", self.type))
        packed.append(struct.pack("!H", 0)) # placeholder for len at index 1
        packed.append(struct.pack("!L", self.experimenter))
        packed.append(self.data)
        length = sum([len(x) for x in packed])
        packed[1] = struct.pack("!H", length)
        return ''.join(packed)

    @staticmethod
    def unpack(reader):
        subtype, = reader.peek('!L', 4)
        subclass = experimenter.subtypes.get(subtype)
        if subclass:
            return subclass.unpack(reader)

        obj = experimenter()
        _type = reader.read("!H")[0]
        assert(_type == 65535)
        _len = reader.read("!H")[0]
        orig_reader = reader
        reader = orig_reader.slice(_len, 4)
        obj.experimenter = reader.read("!L")[0]
        obj.data = str(reader.read_all())
        return obj

    def __eq__(self, other):
        if type(self) != type(other): return False
        if self.experimenter != other.experimenter: return False
        if self.data != other.data: return False
        return True

    def pretty_print(self, q):
        q.text("experimenter {")
        with q.group():
            with q.indent(2):
                q.breakable()
                q.text("data = ");
                q.pp(self.data)
            q.breakable()
        q.text('}')

instruction.subtypes[65535] = experimenter
"""











